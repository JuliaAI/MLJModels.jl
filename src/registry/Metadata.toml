
[BetaML.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.RandomForestRegressor"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Random Forest ensemble for regression with support for Missing data, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load RandomForestRegressor pkg=\"BetaML\"` to use the model.\n→ do `?RandomForestRegressor` for documentation."
":name" = "RandomForestRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:nTrees, :maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :β, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Float64\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:Union{Missing, ScientificTypesBase.Finite}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.RandomForestClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Random Forest ensemble for classification with support for Missing data, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load RandomForestClassifier pkg=\"BetaML\"` to use the model.\n→ do `?RandomForestClassifier` for documentation."
":name" = "RandomForestClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:nTrees, :maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :β, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Float64\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.PerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.PerceptronClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The classical perceptron algorithm using one-vs-all for multiclass, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load PerceptronClassifier pkg=\"BetaML\"` to use the model.\n→ do `?PerceptronClassifier` for documentation."
":name" = "PerceptronClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:initialθ, :initialθ₀, :maxEpochs, :shuffle, :forceOrigin, :returnMeanHyperplane, :rng)`"
":hyperparameter_types" = "`(\"Vector{Float64}\", \"Float64\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.DecisionTreeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.DecisionTreeRegressor"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Decision Tree for regression with support for Missing data, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load DecisionTreeRegressor pkg=\"BetaML\"` to use the model.\n→ do `?DecisionTreeRegressor` for documentation."
":name" = "DecisionTreeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.PegasosClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.PegasosClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The gradient-based linear \"pegasos\" classifier using one-vs-all for multiclass, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load PegasosClassifier pkg=\"BetaML\"` to use the model.\n→ do `?PegasosClassifier` for documentation."
":name" = "PegasosClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:initialθ, :initialθ₀, :λ, :η, :maxEpochs, :shuffle, :forceOrigin, :returnMeanHyperplane, :rng)`"
":hyperparameter_types" = "`(\"Vector{Float64}\", \"Float64\", \"Float64\", \"Function\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KMedoids]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s4692\", N} where {var\"_s4692\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.KMedoids"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The K-medoids clustering algorithm with customisable distance function, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load KMedoids pkg=\"BetaML\"` to use the model.\n→ do `?KMedoids` for documentation."
":name" = "KMedoids"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:K, :dist, :initStrategy, :Z₀, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Function\", \"String\", \"Union{Nothing, Matrix{Float64}}\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s4692\", N} where {var\"_s4692\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.KMeans"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The classical KMeans clustering algorithm, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load KMeans pkg=\"BetaML\"` to use the model.\n→ do `?KMeans` for documentation."
":name" = "KMeans"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:K, :dist, :initStrategy, :Z₀, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Function\", \"String\", \"Union{Nothing, Matrix{Float64}}\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.DecisionTreeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:Union{Missing, ScientificTypesBase.Finite}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.DecisionTreeClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Decision Tree for classification with support for Missing data, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load DecisionTreeClassifier pkg=\"BetaML\"` to use the model.\n→ do `?DecisionTreeClassifier` for documentation."
":name" = "DecisionTreeClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.GMMClusterer]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":output_scitype" = "`AbstractArray{var\"_s4692\", N} where {var\"_s4692\"<:ScientificTypesBase.Multiclass, N}`"
":target_scitype" = "`AbstractArray{var\"_s4171\", N} where {var\"_s4171\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractArray{var\"_s4692\", N} where {var\"_s4692\"<:ScientificTypesBase.Multiclass, N}`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.GMMClusterer"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Expectation-Maximisation clustering algorithm with customisable mixtures, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load GMMClusterer pkg=\"BetaML\"` to use the model.\n→ do `?GMMClusterer` for documentation."
":name" = "GMMClusterer"
":is_supervised" = "`false`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:K, :p₀, :mixtures, :tol, :minVariance, :minCovariance, :initStrategy, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, AbstractVector{Float64}}\", \"Symbol\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.MissingImputator]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.MissingImputator"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Impute missing values using an Expectation-Maximisation clustering algorithm, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load MissingImputator pkg=\"BetaML\"` to use the model.\n→ do `?MissingImputator` for documentation."
":name" = "MissingImputator"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":transform"]
":hyperparameters" = "`(:K, :p₀, :mixtures, :tol, :minVariance, :minCovariance, :initStrategy, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, AbstractVector{Float64}}\", \"Symbol\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KernelPerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s4692\"} where var\"_s4692\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.KernelPerceptronClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The kernel perceptron algorithm using one-vs-one for multiclass, from the Beta Machine Learning Toolkit (BetaML).\n→ based on [BetaML](https://github.com/sylvaticus/BetaML.jl).\n→ do `@load KernelPerceptronClassifier pkg=\"BetaML\"` to use the model.\n→ do `?KernelPerceptronClassifier` for documentation."
":name" = "KernelPerceptronClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:K, :maxEpochs, :initialα, :shuffle, :rng)`"
":hyperparameter_types" = "`(\"Function\", \"Int64\", \"Vector{Int64}\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.KNNClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s67\"} where var\"_s67\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s67\"} where var\"_s67\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s67\"} where var\"_s67\"<:ScientificTypesBase.Finite, AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.KNNClassifier"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors classifier: predicts the class associated with a new point\nby taking a vote over the classes of the K-nearest points.\n\n→ based on [NearestNeighborModels](https://github.com/alan-turing-institute/NearestNeighborModels.jl).\n→ do `@load KNNClassifier pkg=\"NearestNeighborModels\"` to use the model.\n→ do `?KNNClassifier` for documentation."
":name" = "KNNClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.MultitargetKNNClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Finite)`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Finite)}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Finite), AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Density{ScientificTypesBase.Finite})`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.MultitargetKNNClassifier"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors classifier: predicts the class associated with a new point\nby taking a vote over the classes of the K-nearest points.\n\n→ based on [NearestNeighborModels](https://github.com/alan-turing-institute/NearestNeighborModels.jl).\n→ do `@load MultitargetKNNClassifier pkg=\"NearestNeighborModels\"` to use the model.\n→ do `?MultitargetKNNClassifier` for documentation."
":name" = "MultitargetKNNClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":predict_mode", ":fit"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights, :output_type)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\", \"Type{var\\\"_s10\\\"} where var\\\"_s10\\\"<:Union{AbstractDict{K, V} where {K<:Symbol, V<:(AbstractVector{T} where T)}, NamedTuple{names, T} where {N, D, names, T<:Tuple{Vararg{AbstractArray{S, D} where S, N}}}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.MultitargetKNNRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.MultitargetKNNRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors regressor: predicts the response associated with a new point\nby taking an weighted average of the response of the K-nearest points.\n\n→ based on [NearestNeighborModels](https://github.com/alan-turing-institute/NearestNeighborModels.jl).\n→ do `@load MultitargetKNNRegressor pkg=\"NearestNeighborModels\"` to use the model.\n→ do `?MultitargetKNNRegressor` for documentation."
":name" = "MultitargetKNNRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.KNNRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}, AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.KNNRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors regressor: predicts the response associated with a new point\nby taking an weighted average of the response of the K-nearest points.\n\n→ based on [NearestNeighborModels](https://github.com/alan-turing-institute/NearestNeighborModels.jl).\n→ do `@load KNNRegressor pkg=\"NearestNeighborModels\"` to use the model.\n→ do `?KNNRegressor` for documentation."
":name" = "KNNRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.ABODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.ABODDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "ABODDetector from OutlierDetectionNeighbors.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl)."
":name" = "ABODDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :leafsize, :reorder, :parallel, :enhanced)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Integer\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.DNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.DNNDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "DNNDetector from OutlierDetectionNeighbors.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl)."
":name" = "DNNDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:metric, :algorithm, :leafsize, :reorder, :parallel, :d)`"
":hyperparameter_types" = "`(\"Distances.Metric\", \"Symbol\", \"Integer\", \"Bool\", \"Bool\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.LOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.LOFDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LOFDetector from OutlierDetectionNeighbors.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl)."
":name" = "LOFDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :leafsize, :reorder, :parallel)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Integer\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.KNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.KNNDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "KNNDetector from OutlierDetectionNeighbors.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl)."
":name" = "KNNDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :leafsize, :reorder, :parallel, :reduction)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Integer\", \"Bool\", \"Bool\", \"Symbol\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.COFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.COFDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "COFDetector from OutlierDetectionNeighbors.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl)."
":name" = "COFDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :leafsize, :reorder, :parallel)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Integer\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[PartialLeastSquaresRegressor.KPLSRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "PartialLeastSquaresRegressor"
":package_license" = "MIT"
":load_path" = "PartialLeastSquaresRegressor.KPLSRegressor"
":package_uuid" = "f4b1acfe-f311-436c-bb79-8483f53c17d5"
":package_url" = "https://github.com/lalvim/PartialLeastSquaresRegressor.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Kernel Partial Least Squares Regressor. A Kernel PLS2 NIPALS algorithms. Can be used mainly for regression.\n→ based on [PartialLeastSquaresRegressor](https://github.com/lalvim/PartialLeastSquaresRegressor.jl).\n→ do `@load KPLSRegressor pkg=\"PartialLeastSquaresRegressor\"` to use the model.\n→ do `?KPLSRegressor` for documentation."
":name" = "KPLSRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:n_factors, :kernel, :width)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[PartialLeastSquaresRegressor.PLSRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "PartialLeastSquaresRegressor"
":package_license" = "MIT"
":load_path" = "PartialLeastSquaresRegressor.PLSRegressor"
":package_uuid" = "f4b1acfe-f311-436c-bb79-8483f53c17d5"
":package_url" = "https://github.com/lalvim/PartialLeastSquaresRegressor.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Partial Least Squares Regressor. Contains PLS1, PLS2 (multi target) algorithms. Can be used mainly for regression.\n→ based on [PartialLeastSquaresRegressor](https://github.com/lalvim/PartialLeastSquaresRegressor.jl).\n→ do `@load PLSRegressor pkg=\"PartialLeastSquaresRegressor\"` to use the model.\n→ do `?PLSRegressor` for documentation."
":name" = "PLSRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:n_factors,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.QuantileRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.QuantileRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Quantile Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load QuantileRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?QuantileRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load QuantileRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?QuantileRegressor` for documentation."
":name" = "QuantileRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:delta, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LogisticClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LogisticClassifier"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Classifier corresponding to the loss function ``L(y, Xθ) + λ|θ|₂²/2 + γ|θ|₁`` where `L` is the logistic loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LogisticClassifier pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LogisticClassifier` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load LogisticClassifier pkg=\"MLJLinearModels\"` to use the model.\n→ do `?LogisticClassifier` for documentation."
":name" = "LogisticClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.MultinomialClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.MultinomialClassifier"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Classifier corresponding to the loss function ``L(y, Xθ) + λ|θ|₂²/2 + γ|θ|₁`` where `L` is the multinomial loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load MultinomialClassifier pkg=\"MLJLinearModels\" to use the model.`\n→ do `?MultinomialClassifier` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load MultinomialClassifier pkg=\"MLJLinearModels\"` to use the model.\n→ do `?MultinomialClassifier` for documentation."
":name" = "MultinomialClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LADRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LADRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Absolute Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LADRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LADRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load LADRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?LADRegressor` for documentation."
":name" = "LADRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.RidgeRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₂²/2``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load RidgeRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?RidgeRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load RidgeRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?RidgeRegressor` for documentation."
":name" = "RidgeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.RobustRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.RobustRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` for a given robust `ρ`.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load RobustRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?RobustRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load RobustRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?RobustRegressor` for documentation."
":name" = "RobustRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:rho, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"MLJLinearModels.RobustRho\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.ElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.ElasticNetRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₂²/2 + γ|θ|₁``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load ElasticNetRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?ElasticNetRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load ElasticNetRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?ElasticNetRegressor` for documentation."
":name" = "ElasticNetRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :gamma, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LinearRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LinearRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LinearRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load LinearRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?LinearRegressor` for documentation."
":name" = "LinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :solver)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LassoRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₁``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LassoRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LassoRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load LassoRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?LassoRegressor` for documentation."
":name" = "LassoRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.HuberRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.HuberRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Huber Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load HuberRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?HuberRegressor` for documentation.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl).\n→ do `@load HuberRegressor pkg=\"MLJLinearModels\"` to use the model.\n→ do `?HuberRegressor` for documentation."
":name" = "HuberRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:delta, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ProbabilisticSGDClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ProbabilisticSGDClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear classifier with stochastic gradient descent training.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ProbabilisticSGDClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?ProbabilisticSGDClassifier` for documentation."
":name" = "ProbabilisticSGDClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :n_jobs, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeCVClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeCVClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regression classifier with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RidgeCVClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?RidgeCVClassifier` for documentation."
":name" = "RidgeCVClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alphas, :fit_intercept, :normalize, :scoring, :cv, :class_weight, :store_cv_values)`"
":hyperparameter_types" = "`(\"AbstractArray{Float64, N} where N\", \"Bool\", \"Bool\", \"Any\", \"Int64\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LogisticClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LogisticClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Logistic regression classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LogisticClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?LogisticClassifier` for documentation."
":name" = "LogisticClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:penalty, :dual, :tol, :C, :fit_intercept, :intercept_scaling, :class_weight, :random_state, :solver, :max_iter, :multi_class, :verbose, :warm_start, :n_jobs, :l1_ratio)`"
":hyperparameter_types" = "`(\"String\", \"Bool\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Any\", \"Any\", \"String\", \"Int64\", \"String\", \"Int64\", \"Bool\", \"Union{Nothing, Int64}\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RandomForestRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Random forest regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RandomForestRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?RandomForestRegressor` for documentation."
":name" = "RandomForestRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :ccp_alpha, :max_samples)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Float64\", \"Union{Nothing, Float64, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ElasticNetCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ElasticNetCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Elastic net regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ElasticNetCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?ElasticNetCVRegressor` for documentation."
":name" = "ElasticNetCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:l1_ratio, :eps, :n_alphas, :alphas, :fit_intercept, :normalize, :precompute, :max_iter, :tol, :cv, :copy_X, :verbose, :n_jobs, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PerceptronClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Perceptron classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load PerceptronClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?PerceptronClassifier` for documentation."
":name" = "PerceptronClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:penalty, :alpha, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :eta0, :n_jobs, :random_state, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start)`"
":hyperparameter_types" = "`(\"Union{Nothing, String}\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskLassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskLassoRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MultiTask Lasso regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MultiTaskLassoRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?MultiTaskLassoRegressor` for documentation."
":name" = "MultiTaskLassoRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :max_iter, :tol, :copy_X, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LinearRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ordinary least-square regression (OLS).\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LinearRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LinearRegressor` for documentation."
":name" = "LinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :normalize, :copy_X, :n_jobs)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DBSCAN]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DBSCAN"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Density-Based Spatial Clustering of Applications with Noise. Finds core samples of high density and expands clusters from them. Good for data which contains clusters of similar density.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load DBSCAN pkg=\"ScikitLearn\"` to use the model.\n→ do `?DBSCAN` for documentation."
":name" = "DBSCAN"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit"]
":hyperparameters" = "`(:eps, :min_samples, :metric, :algorithm, :leaf_size, :p, :n_jobs)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"String\", \"String\", \"Int64\", \"Union{Nothing, Float64}\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RidgeRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?RidgeRegressor` for documentation."
":name" = "RidgeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :solver, :random_state)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Bool\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsICRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsICRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lasso model with Lars using BIC or AIC for model selection.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LassoLarsICRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LassoLarsICRegressor` for documentation."
":name" = "LassoLarsICRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:criterion, :fit_intercept, :verbose, :normalize, :precompute, :max_iter, :eps, :copy_X, :positive)`"
":hyperparameter_types" = "`(\"String\", \"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ARDRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ARDRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bayesian ARD regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ARDRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?ARDRegressor` for documentation."
":name" = "ARDRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_iter, :tol, :alpha_1, :alpha_2, :lambda_1, :lambda_2, :compute_score, :threshold_lambda, :fit_intercept, :normalize, :copy_X, :verbose)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMNuRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMNuRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Nu-Support Vector Regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMNuRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMNuRegressor` for documentation."
":name" = "SVMNuRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:nu, :C, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Any\", \"Float64\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regression classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RidgeClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?RidgeClassifier` for documentation."
":name" = "RidgeClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :class_weight, :solver, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Float64\", \"Any\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SGDRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SGDRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Stochastic gradient descent-based regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SGDRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?SGDRegressor` for documentation."
":name" = "SGDRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Union{Bool, Int64}\", \"Float64\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ComplementNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ComplementNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Similar to Multinomial NB classifier but with more robust assumptions. Suited for imbalanced datasets.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ComplementNBClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?ComplementNBClassifier` for documentation."
":name" = "ComplementNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_prior, :class_prior, :norm)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.HuberRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.HuberRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Huber regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load HuberRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?HuberRegressor` for documentation."
":name" = "HuberRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:epsilon, :max_iter, :alpha, :warm_start, :fit_intercept, :tol)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMNuClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMNuClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Nu-Support Vector Classification.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMNuClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMNuClassifier` for documentation."
":name" = "SVMNuClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:nu, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter, :decision_function_shape, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GradientBoostingClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GradientBoostingClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gradient boosting ensemble classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load GradientBoostingClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?GradientBoostingClassifier` for documentation."
":name" = "GradientBoostingClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:loss, :learning_rate, :n_estimators, :subsample, :criterion, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_depth, :min_impurity_decrease, :init, :random_state, :max_features, :verbose, :max_leaf_nodes, :warm_start, :validation_fraction, :n_iter_no_change, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Float64\", \"Int64\", \"Float64\", \"String\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Int64\", \"Float64\", \"Any\", \"Any\", \"Union{Nothing, Float64, Int64, String}\", \"Int64\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\", \"Union{Nothing, Int64}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianProcessRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianProcessRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gaussian process regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load GaussianProcessRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?GaussianProcessRegressor` for documentation."
":name" = "GaussianProcessRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :alpha, :optimizer, :n_restarts_optimizer, :normalize_y, :copy_X_train, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Union{Float64, AbstractArray}\", \"Any\", \"Int64\", \"Bool\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMLinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMLinearRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear Support Vector Regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMLinearRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMLinearRegressor` for documentation."
":name" = "SVMLinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:epsilon, :tol, :C, :loss, :fit_intercept, :intercept_scaling, :dual, :random_state, :max_iter)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Float64\", \"String\", \"Bool\", \"Float64\", \"Bool\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LarsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LarsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lars regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LarsRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LarsRegressor` for documentation."
":name" = "LarsRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :verbose, :normalize, :precompute, :n_nonzero_coefs, :eps, :copy_X, :fit_path)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MeanShift]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MeanShift"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Mean shift clustering using a flat kernel. Mean shift clustering aims to discover \"blobs\" in a smooth density of samples. It is a centroid-based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region. These candidates are then filtered in a post-processing stage to eliminate near-duplicates to form the final set of centroids.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MeanShift pkg=\"ScikitLearn\"` to use the model.\n→ do `?MeanShift` for documentation."
":name" = "MeanShift"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:bandwidth, :seeds, :bin_seeding, :min_bin_freq, :cluster_all, :n_jobs)`"
":hyperparameter_types" = "`(\"Union{Nothing, Float64}\", \"Union{Nothing, AbstractArray}\", \"Bool\", \"Int64\", \"Bool\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AdaBoostRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AdaBoostRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "AdaBoost ensemble regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load AdaBoostRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?AdaBoostRegressor` for documentation."
":name" = "AdaBoostRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :learning_rate, :loss, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AffinityPropagation]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AffinityPropagation"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Perform Affinity Propagation Clustering of data.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load AffinityPropagation pkg=\"ScikitLearn\"` to use the model.\n→ do `?AffinityPropagation` for documentation."
":name" = "AffinityPropagation"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:damping, :max_iter, :convergence_iter, :copy, :preference, :affinity, :verbose)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Int64\", \"Bool\", \"Any\", \"String\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskLassoCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskLassoCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MultiTask Lasso regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MultiTaskLassoCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?MultiTaskLassoCVRegressor` for documentation."
":name" = "MultiTaskLassoCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:eps, :n_alphas, :alphas, :fit_intercept, :normalize, :max_iter, :tol, :copy_X, :cv, :verbose, :n_jobs, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OrthogonalMatchingPursuitRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OrthogonalMatchingPursuitRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Orthogonal Matching Pursuit (OMP) model.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load OrthogonalMatchingPursuitRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?OrthogonalMatchingPursuitRegressor` for documentation."
":name" = "OrthogonalMatchingPursuitRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_nonzero_coefs, :tol, :fit_intercept, :normalize, :precompute)`"
":hyperparameter_types" = "`(\"Union{Nothing, Int64}\", \"Union{Nothing, Float64}\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RidgeCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?RidgeCVRegressor` for documentation."
":name" = "RidgeCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alphas, :fit_intercept, :normalize, :scoring, :cv, :gcv_mode, :store_cv_values)`"
":hyperparameter_types" = "`(\"Any\", \"Bool\", \"Bool\", \"Any\", \"Any\", \"Union{Nothing, String}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PassiveAggressiveClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PassiveAggressiveClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Passive aggressive classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load PassiveAggressiveClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?PassiveAggressiveClassifier` for documentation."
":name" = "PassiveAggressiveClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:C, :fit_intercept, :max_iter, :tol, :early_stopping, :validation_fraction, :n_iter_no_change, :shuffle, :verbose, :loss, :n_jobs, :random_state, :warm_start, :class_weight, :average)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Any\", \"Bool\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Epsilon-Support Vector Regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMRegressor` for documentation."
":name" = "SVMRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :degree, :gamma, :coef0, :tol, :C, :epsilon, :shrinking, :cache_size, :max_iter)`"
":hyperparameter_types" = "`(\"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BernoulliNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BernoulliNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Binomial naive bayes classifier. It is suitable for classification with binary features; features will be binarized based on the `binarize` keyword (unless it's `nothing` in which case the features are assumed to be binary).\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BernoulliNBClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?BernoulliNBClassifier` for documentation."
":name" = "BernoulliNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :binarize, :fit_prior, :class_prior)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Nothing, Float64}\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gaussian naive bayes model.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load GaussianNBClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?GaussianNBClassifier` for documentation."
":name" = "GaussianNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:priors, :var_smoothing)`"
":hyperparameter_types" = "`(\"Union{Nothing, AbstractVector{Float64}}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ExtraTreesClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ExtraTreesClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Extra trees classifier, fits a number of randomized decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ExtraTreesClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?ExtraTreesClassifier` for documentation."
":name" = "ExtraTreesClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :class_weight)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KMeans"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Means algorithm: find K centroids corresponding to K clusters in the data.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load KMeans pkg=\"ScikitLearn\"` to use the model.\n→ do `?KMeans` for documentation."
":name" = "KMeans"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:n_clusters, :n_init, :max_iter, :tol, :verbose, :random_state, :copy_x, :n_jobs, :algorithm, :precompute_distances, :init)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Union{Nothing, Int64}\", \"String\", \"Union{Bool, String}\", \"Union{String, AbstractArray}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskElasticNetCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskElasticNetCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MultiTask Elastic Net regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MultiTaskElasticNetCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?MultiTaskElasticNetCVRegressor` for documentation."
":name" = "MultiTaskElasticNetCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:l1_ratio, :eps, :n_alphas, :alphas, :fit_intercept, :normalize, :max_iter, :tol, :cv, :copy_X, :verbose, :n_jobs, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lasso model fit with least angle regression (LARS) with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LassoLarsCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LassoLarsCVRegressor` for documentation."
":name" = "LassoLarsCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :verbose, :max_iter, :normalize, :precompute, :cv, :max_n_alphas, :n_jobs, :eps, :copy_X, :positive)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Int64\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Any\", \"Int64\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OrthogonalMatchingPursuitCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OrthogonalMatchingPursuitCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Orthogonal Matching Pursuit (OMP) model with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load OrthogonalMatchingPursuitCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?OrthogonalMatchingPursuitCVRegressor` for documentation."
":name" = "OrthogonalMatchingPursuitCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:copy, :fit_intercept, :normalize, :max_iter, :cv, :n_jobs, :verbose)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Union{Nothing, Int64}\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AdaBoostClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AdaBoostClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Adaboost ensemble classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load AdaBoostClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?AdaBoostClassifier` for documentation."
":name" = "AdaBoostClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :learning_rate, :algorithm, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PassiveAggressiveRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PassiveAggressiveRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Passive Aggressive Regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load PassiveAggressiveRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?PassiveAggressiveRegressor` for documentation."
":name" = "PassiveAggressiveRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:C, :fit_intercept, :max_iter, :tol, :early_stopping, :validation_fraction, :n_iter_no_change, :shuffle, :verbose, :loss, :epsilon, :random_state, :warm_start, :average)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Union{Bool, Int64}\", \"String\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianRidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianRidgeRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bayesian ridge regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BayesianRidgeRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?BayesianRidgeRegressor` for documentation."
":name" = "BayesianRidgeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_iter, :tol, :alpha_1, :alpha_2, :lambda_1, :lambda_2, :compute_score, :fit_intercept, :normalize, :copy_X, :verbose)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RANSACRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RANSACRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "RANSAC regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RANSACRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?RANSACRegressor` for documentation."
":name" = "RANSACRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:base_estimator, :min_samples, :residual_threshold, :is_data_valid, :is_model_valid, :max_trials, :max_skips, :stop_n_inliers, :stop_score, :stop_probability, :loss, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Union{Float64, Int64}\", \"Union{Nothing, Float64}\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Function, String}\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BaggingClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BaggingClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bagging ensemble classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BaggingClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?BaggingClassifier` for documentation."
":name" = "BaggingClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :max_samples, :max_features, :bootstrap, :bootstrap_features, :oob_score, :warm_start, :n_jobs, :random_state, :verbose)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianProcessClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianProcessClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gaussian process classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load GaussianProcessClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?GaussianProcessClassifier` for documentation."
":name" = "GaussianProcessClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :optimizer, :n_restarts_optimizer, :copy_X_train, :random_state, :max_iter_predict, :warm_start, :multi_class)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Int64\", \"Bool\", \"Any\", \"Int64\", \"Bool\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OPTICS]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OPTICS"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "OPTICS (Ordering Points To Identify the Clustering Structure), closely related to DBSCAN, finds core sample of high density and expands clusters from them. Unlike DBSCAN, keeps cluster hierarchy for a variable neighborhood radius. Better suited for usage on large datasets than the current sklearn implementation of DBSCAN.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load OPTICS pkg=\"ScikitLearn\"` to use the model.\n→ do `?OPTICS` for documentation."
":name" = "OPTICS"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit"]
":hyperparameters" = "`(:min_samples, :max_eps, :metric, :p, :cluster_method, :eps, :xi, :predecessor_correction, :min_cluster_size, :algorithm, :leaf_size, :n_jobs)`"
":hyperparameter_types" = "`(\"Union{Float64, Int64}\", \"Float64\", \"String\", \"Int64\", \"String\", \"Union{Nothing, Float64}\", \"Float64\", \"Bool\", \"Union{Nothing, Float64, Int64}\", \"String\", \"Int64\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KNeighborsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KNeighborsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors regressor: predicts the response associated with a new point by taking an average of the response of the K-nearest points.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load KNeighborsRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?KNeighborsRegressor` for documentation."
":name" = "KNeighborsRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_neighbors, :weights, :algorithm, :leaf_size, :p, :metric, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Function, String}\", \"String\", \"Int64\", \"Int64\", \"Any\", \"Any\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MiniBatchKMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MiniBatchKMeans"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Mini-Batch K-Means clustering.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MiniBatchKMeans pkg=\"ScikitLearn\"` to use the model.\n→ do `?MiniBatchKMeans` for documentation."
":name" = "MiniBatchKMeans"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:n_clusters, :max_iter, :batch_size, :verbose, :compute_labels, :random_state, :tol, :max_no_improvement, :init_size, :n_init, :init, :reassignment_ratio)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Any\", \"Float64\", \"Int64\", \"Union{Nothing, Int64}\", \"Int64\", \"Union{String, AbstractArray}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lasso regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LassoCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LassoCVRegressor` for documentation."
":name" = "LassoCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:eps, :n_alphas, :alphas, :fit_intercept, :normalize, :precompute, :max_iter, :tol, :copy_X, :cv, :verbose, :n_jobs, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DummyRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DummyRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "DummyRegressor is a regressor that makes predictions using simple rules.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load DummyRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?DummyRegressor` for documentation."
":name" = "DummyRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:strategy, :constant, :quantile)`"
":hyperparameter_types" = "`(\"String\", \"Any\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lasso model fit with least angle regression (LARS).\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LassoLarsRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LassoLarsRegressor` for documentation."
":name" = "LassoLarsRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_intercept, :verbose, :normalize, :precompute, :max_iter, :eps, :copy_X, :fit_path, :positive)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LarsCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LarsCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lars regression with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LarsCVRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LarsCVRegressor` for documentation."
":name" = "LarsCVRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :verbose, :max_iter, :normalize, :precompute, :cv, :max_n_alphas, :n_jobs, :eps, :copy_X)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Int64\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Any\", \"Int64\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KNeighborsClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KNeighborsClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors classifier: predicts the class associated with a new point by taking a vote over the classes of the K-nearest points.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load KNeighborsClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?KNeighborsClassifier` for documentation."
":name" = "KNeighborsClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_neighbors, :weights, :algorithm, :leaf_size, :p, :metric, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Function, String}\", \"String\", \"Int64\", \"Int64\", \"Any\", \"Any\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMLinearClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMLinearClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear Support Vector Classification.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMLinearClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMLinearClassifier` for documentation."
":name" = "SVMLinearClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:penalty, :loss, :dual, :tol, :C, :multi_class, :fit_intercept, :intercept_scaling, :random_state, :max_iter)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Bool\", \"Float64\", \"Float64\", \"String\", \"Bool\", \"Float64\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.FeatureAgglomeration]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.FeatureAgglomeration"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Similar to AgglomerativeClustering, but recursively merges features instead of samples.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load FeatureAgglomeration pkg=\"ScikitLearn\"` to use the model.\n→ do `?FeatureAgglomeration` for documentation."
":name" = "FeatureAgglomeration"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:n_clusters, :memory, :connectivity, :affinity, :compute_full_tree, :linkage, :distance_threshold)`"
":hyperparameter_types" = "`(\"Int64\", \"Any\", \"Any\", \"Any\", \"Union{Bool, String}\", \"String\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DummyClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DummyClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "DummyClassifier is a classifier that makes predictions using simple rules.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load DummyClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?DummyClassifier` for documentation."
":name" = "DummyClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:strategy, :constant, :random_state)`"
":hyperparameter_types" = "`(\"String\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BaggingRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BaggingRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bagging ensemble regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BaggingRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?BaggingRegressor` for documentation."
":name" = "BaggingRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :max_samples, :max_features, :bootstrap, :bootstrap_features, :oob_score, :warm_start, :n_jobs, :random_state, :verbose)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianQDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianQDA"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bayesian Quadratic Discriminant Analysis.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BayesianQDA pkg=\"ScikitLearn\"` to use the model.\n→ do `?BayesianQDA` for documentation."
":name" = "BayesianQDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:priors, :reg_param, :store_covariance, :tol)`"
":hyperparameter_types" = "`(\"Union{Nothing, AbstractVector{T} where T}\", \"Float64\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianLDA"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Bayesian Linear Discriminant Analysis.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load BayesianLDA pkg=\"ScikitLearn\"` to use the model.\n→ do `?BayesianLDA` for documentation."
":name" = "BayesianLDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:solver, :shrinkage, :priors, :n_components, :store_covariance, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Union{Nothing, Float64, String}\", \"Union{Nothing, AbstractVector{T} where T}\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SGDClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s6201\"} where var\"_s6201\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SGDClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear classifier with stochastic gradient descent training.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SGDClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?SGDClassifier` for documentation."
":name" = "SGDClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :n_jobs, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.TheilSenRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.TheilSenRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Theil-Sen regressor.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load TheilSenRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?TheilSenRegressor` for documentation."
":name" = "TheilSenRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :copy_X, :max_subpopulation, :n_subsamples, :max_iter, :tol, :random_state, :n_jobs, :verbose)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Int64\", \"Union{Nothing, Int64}\", \"Int64\", \"Float64\", \"Any\", \"Union{Nothing, Int64}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SpectralClustering]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SpectralClustering"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Apply clustering to a projection of the normalized Laplacian.\n    In practice Spectral Clustering is very useful when the structure of the individual clusters is highly non-convex or more generally when a measure of the center and spread of the cluster is not a suitable description of the complete cluster. For instance when clusters are nested circles on the 2D plane.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SpectralClustering pkg=\"ScikitLearn\"` to use the model.\n→ do `?SpectralClustering` for documentation."
":name" = "SpectralClustering"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit"]
":hyperparameters" = "`(:n_clusters, :eigen_solver, :random_state, :n_init, :gamma, :affinity, :n_neighbors, :eigen_tol, :assign_labels, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, String}\", \"Any\", \"Int64\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"String\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.Birch]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.Birch"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Memory-efficient, online-learning algorithm provided as an alternative to MiniBatchKMeans. Note: noisy samples are given the label -1.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load Birch pkg=\"ScikitLearn\"` to use the model.\n→ do `?Birch` for documentation."
":name" = "Birch"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:threshold, :branching_factor, :n_clusters, :compute_labels, :copy)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Int64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AgglomerativeClustering]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AgglomerativeClustering"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Recursively merges the pair of clusters that minimally increases a given linkage distance. Note: there is no `predict` or `transform` method\n    associated with it; instead, inspect the `fitted_params`.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load AgglomerativeClustering pkg=\"ScikitLearn\"` to use the model.\n→ do `?AgglomerativeClustering` for documentation."
":name" = "AgglomerativeClustering"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit"]
":hyperparameters" = "`(:n_clusters, :affinity, :memory, :connectivity, :compute_full_tree, :linkage, :distance_threshold)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Any\", \"Any\", \"Union{Bool, String}\", \"String\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ElasticNetRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Elastic net regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ElasticNetRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?ElasticNetRegressor` for documentation."
":name" = "ElasticNetRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :l1_ratio, :fit_intercept, :normalize, :precompute, :max_iter, :copy_X, :tol, :warm_start, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Bool\", \"Bool\", \"Union{Bool, AbstractMatrix{T} where T}\", \"Int64\", \"Bool\", \"Float64\", \"Bool\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RandomForestClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Random forest classifier.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load RandomForestClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?RandomForestClassifier` for documentation."
":name" = "RandomForestClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :class_weight, :ccp_alpha, :max_samples)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Any\", \"Float64\", \"Union{Nothing, Float64, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LogisticCVClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s5885\"} where var\"_s5885\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LogisticCVClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Logistic regression classifier with built-in cross-validation.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LogisticCVClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?LogisticCVClassifier` for documentation."
":name" = "LogisticCVClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:Cs, :fit_intercept, :cv, :dual, :penalty, :scoring, :solver, :tol, :max_iter, :class_weight, :n_jobs, :verbose, :refit, :intercept_scaling, :multi_class, :random_state, :l1_ratios)`"
":hyperparameter_types" = "`(\"Union{Int64, AbstractVector{Float64}}\", \"Bool\", \"Any\", \"Bool\", \"String\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Any\", \"Union{Nothing, Int64}\", \"Int64\", \"Bool\", \"Float64\", \"String\", \"Any\", \"Union{Nothing, AbstractVector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskElasticNetRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MultiTask Elastic Net regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MultiTaskElasticNetRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?MultiTaskElasticNetRegressor` for documentation."
":name" = "MultiTaskElasticNetRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :l1_ratio, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :warm_start, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Float64, Vector{Float64}}\", \"Bool\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ExtraTreesRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ExtraTreesRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Extra trees regressor, fits a number of randomized decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load ExtraTreesRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?ExtraTreesRegressor` for documentation."
":name" = "ExtraTreesRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Lasso regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load LassoRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?LassoRegressor` for documentation."
":name" = "LassoRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :precompute, :copy_X, :max_iter, :tol, :warm_start, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Union{Bool, AbstractMatrix{T} where T}\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultinomialNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultinomialNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multinomial naive bayes classifier. It is suitable for classification with discrete features (e.g. word counts for text classification).\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load MultinomialNBClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?MultinomialNBClassifier` for documentation."
":name" = "MultinomialNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha, :fit_prior, :class_prior)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GradientBoostingRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GradientBoostingRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gradient boosting ensemble regression.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load GradientBoostingRegressor pkg=\"ScikitLearn\"` to use the model.\n→ do `?GradientBoostingRegressor` for documentation."
":name" = "GradientBoostingRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:loss, :learning_rate, :n_estimators, :subsample, :criterion, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_depth, :min_impurity_decrease, :init, :random_state, :max_features, :alpha, :verbose, :max_leaf_nodes, :warm_start, :validation_fraction, :n_iter_no_change, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Float64\", \"Int64\", \"Float64\", \"String\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Int64\", \"Float64\", \"Any\", \"Any\", \"Union{Nothing, Float64, Int64, String}\", \"Float64\", \"Int64\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\", \"Union{Nothing, Int64}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "C-Support Vector Classification.\n→ based on [ScikitLearn](https://github.com/cstjean/ScikitLearn.jl).\n→ do `@load SVMClassifier pkg=\"ScikitLearn\"` to use the model.\n→ do `?SVMClassifier` for documentation."
":name" = "SVMClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:C, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter, :decision_function_shape, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ParallelKMeans.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s6489\", N} where {var\"_s6489\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "ParallelKMeans"
":package_license" = "MIT"
":load_path" = "ParallelKMeans.KMeans"
":package_uuid" = "42b8e9d4-006b-409a-8472-7f34b3fb58af"
":package_url" = "https://github.com/PyDataBlog/ParallelKMeans.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Parallel & lightning fast implementation of all available variants of the KMeans clustering algorithm\n                             in native Julia. Compatible with Julia 1.3+\n→ based on [ParallelKMeans](https://github.com/PyDataBlog/ParallelKMeans.jl).\n→ do `@load KMeans pkg=\"ParallelKMeans\"` to use the model.\n→ do `?KMeans` for documentation."
":name" = "KMeans"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:algo, :k_init, :k, :tol, :max_iters, :copy, :threads, :rng, :weights, :init)`"
":hyperparameter_types" = "`(\"Union{Symbol, ParallelKMeans.AbstractKMeansAlg}\", \"String\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Int64\", \"Union{Int64, Random.AbstractRNG}\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NaiveBayes.GaussianNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NaiveBayes"
":package_license" = "unknown"
":load_path" = "MLJNaiveBayesInterface.GaussianNBClassifier"
":package_uuid" = "9bbee03b-0db5-5f46-924f-b5c9c21b8c60"
":package_url" = "https://github.com/dfdx/NaiveBayes.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "GaussianNBClassifier from NaiveBayes.jl.\n[Documentation](https://github.com/dfdx/NaiveBayes.jl)."
":name" = "GaussianNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NaiveBayes.MultinomialNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NaiveBayes"
":package_license" = "unknown"
":load_path" = "MLJNaiveBayesInterface.MultinomialNBClassifier"
":package_uuid" = "9bbee03b-0db5-5f46-924f-b5c9c21b8c60"
":package_url" = "https://github.com/dfdx/NaiveBayes.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MultinomialNBClassifier from NaiveBayes.jl.\n[Documentation](https://github.com/dfdx/NaiveBayes.jl)."
":name" = "MultinomialNBClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:alpha,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.LDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.LDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Multiclass linear discriminant analysis. The algorithm learns a\nprojection matrix `P` that projects a feature matrix `Xtrain` onto a lower dimensional\nspace of dimension `out_dim` such that the trace of the transformed between-class \nscatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the transformed \nwithin-class scatter matrix (`Pᵀ*Sw*P`).The projection matrix is scaled such that \n`Pᵀ*Sw*P=I` or `Pᵀ*Σw*P=I`(where `Σw` is the within-class covariance matrix) .\nPredicted class posterior probability for feature matrix `Xtest` are derived by \napplying a softmax transformationto a matrix `Pr`, such that  rowᵢ of `Pr` contains \ncomputed distances(based on a distance metric) in the transformed space of rowᵢ in \n`Xtest` to the centroid of each class.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load LDA pkg=\"MultivariateStats\"` to use the model.\n→ do `?LDA` for documentation."
":name" = "LDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:method, :cov_w, :cov_b, :out_dim, :regcoef, :dist)`"
":hyperparameter_types" = "`(\"Symbol\", \"StatsBase.CovarianceEstimator\", \"StatsBase.CovarianceEstimator\", \"Int64\", \"Float64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.MultitargetLinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.MultitargetLinearRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multitarget Linear Regression. Learns linear combinations of given\nvariables to fit the responses by minimizing the squared error between.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load MultitargetLinearRegressor pkg=\"MultivariateStats\"` to use the model.\n→ do `?MultitargetLinearRegressor` for documentation."
":name" = "MultitargetLinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:bias,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.BayesianSubspaceLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.BayesianSubspaceLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "   Bayesian Multiclass linear discriminant analysis. Suitable for high dimensional data \n(Avoids computing scatter matrices `Sw` ,`Sb`). The algorithm learns a projection \nmatrix `P = W*L` (`Sw`), that projects a feature matrix `Xtrain` onto a lower \ndimensional space of dimension `nc-1` such that the trace of the transformed \nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the \ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = mult*I` or `Pᵀ*Σw*P=mult/(n-nc)*I` (where `n` is the number of \ntraining samples, `mult` is  one of `n` or `1` depending on whether `Sb` is normalized,\n`Σw` is the within-class covariance matrix, and `nc` is the number of unique classes in\n`y`) and also obeys `Wᵀ*Sb*p = λ*Wᵀ*Sw*p`, for every column `p` in `P`.\nPosterior class probability distibution are derived by applying Bayes rule with a\nmultivariate Gaussian class-conditional distribution\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load BayesianSubspaceLDA pkg=\"MultivariateStats\"` to use the model.\n→ do `?BayesianSubspaceLDA` for documentation."
":name" = "BayesianSubspaceLDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:normalize, :out_dim, :priors)`"
":hyperparameter_types" = "`(\"Bool\", \"Int64\", \"Union{Nothing, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.FactorAnalysis]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.FactorAnalysis"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Factor Analysis\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load FactorAnalysis pkg=\"MultivariateStats\"` to use the model.\n→ do `?FactorAnalysis` for documentation."
":name" = "FactorAnalysis"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:method, :maxoutdim, :maxiter, :tol, :eta, :mean)`"
":hyperparameter_types" = "`(\"Symbol\", \"Int64\", \"Int64\", \"Real\", \"Real\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.LinearRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear Regression. Learns a linear combination of given\nvariables to fit the response by minimizing the squared error between.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load LinearRegressor pkg=\"MultivariateStats\"` to use the model.\n→ do `?LinearRegressor` for documentation."
":name" = "LinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:bias,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.ICA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.ICA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Independent component analysis.\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load ICA pkg=\"MultivariateStats\"` to use the model.\n→ do `?ICA` for documentation."
":name" = "ICA"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:k, :alg, :fun, :do_whiten, :maxiter, :tol, :winit, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Symbol\", \"Bool\", \"Int64\", \"Real\", \"Union{Nothing, Matrix{var\\\"_s9827\\\"} where var\\\"_s9827\\\"<:Real}\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.PPCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.PPCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Probabilistic principal component analysis\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load PPCA pkg=\"MultivariateStats\"` to use the model.\n→ do `?PPCA` for documentation."
":name" = "PPCA"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:maxoutdim, :method, :maxiter, :tol, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Int64\", \"Real\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.RidgeRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regressor with regularization parameter lambda. Learns a\nlinear regression with a penalty on the l2 norm of the coefficients.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load RidgeRegressor pkg=\"MultivariateStats\"` to use the model.\n→ do `?RidgeRegressor` for documentation."
":name" = "RidgeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :bias)`"
":hyperparameter_types" = "`(\"Union{Real, AbstractVecOrMat{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.KernelPCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.KernelPCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Kernel principal component analysis.\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load KernelPCA pkg=\"MultivariateStats\"` to use the model.\n→ do `?KernelPCA` for documentation."
":name" = "KernelPCA"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:maxoutdim, :kernel, :solver, :inverse, :beta, :tol, :maxiter)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, Function}\", \"Symbol\", \"Bool\", \"Real\", \"Real\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.MultitargetRidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.MultitargetRidgeRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multitarget Ridge regressor with regularization parameter lambda. Learns a\nMultitarget linear regression with a penalty on the l2 norm of the coefficients.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load MultitargetRidgeRegressor pkg=\"MultivariateStats\"` to use the model.\n→ do `?MultitargetRidgeRegressor` for documentation."
":name" = "MultitargetRidgeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:lambda, :bias)`"
":hyperparameter_types" = "`(\"Union{Real, AbstractVecOrMat{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.SubspaceLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.SubspaceLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multiclass linear discriminant analysis. Suitable for high\ndimensional data (Avoids computing scatter matrices `Sw` ,`Sb`). The algorithm learns a\nprojection matrix `P = W*L` that projects a feature matrix `Xtrain` onto a lower\ndimensional space of dimension `nc - 1` such that the trace of the transformed\nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the\ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = mult*I` or `Pᵀ*Σw*P=mult/(n-nc)*I` (where `n` is the number of \ntraining samples, mult` is  one of `n` or `1` depending on whether `Sb` is normalized, \n`Σw` is the within-class covariance matrix, and `nc` is the number of unique classes \nin `y`) and also obeys `Wᵀ*Sb*p = λ*Wᵀ*Sw*p`, for every column `p` in `P`.\nPredicted class posterior probability for feature matrix `Xtest` are derived by \napplying a softmax transformation to a matrix `Pr`, such that  rowᵢ of `Pr` contains \ncomputed distances(based on a distance metric) in the transformed space of rowᵢ in \n`Xtest` to the centroid of each class.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load SubspaceLDA pkg=\"MultivariateStats\"` to use the model.\n→ do `?SubspaceLDA` for documentation."
":name" = "SubspaceLDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:normalize, :out_dim, :dist)`"
":hyperparameter_types" = "`(\"Bool\", \"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.BayesianLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.BayesianLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Bayesian Multiclass linear discriminant analysis. The algorithm\nlearns a projection matrix `P` that projects a feature matrix `Xtrain` onto a lower\ndimensional space of dimension `out_dim` such that the trace of the transformed\nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the\ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = n` or `Pᵀ*Σw*P=I` (Where `n` is the number of training samples \nand `Σw` is the within-class covariance matrix).\nPredicted class posterior probability distibution are derived by applying Bayes rule \nwith a multivariate Gaussian class-conditional distribution.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load BayesianLDA pkg=\"MultivariateStats\"` to use the model.\n→ do `?BayesianLDA` for documentation."
":name" = "BayesianLDA"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:method, :cov_w, :cov_b, :out_dim, :regcoef, :priors)`"
":hyperparameter_types" = "`(\"Symbol\", \"StatsBase.CovarianceEstimator\", \"StatsBase.CovarianceEstimator\", \"Int64\", \"Float64\", \"Union{Nothing, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.PCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.PCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Principal component analysis. Learns a linear transformation to\nproject the data  on a lower dimensional space while preserving most of the initial\nvariance.\n\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load PCA pkg=\"MultivariateStats\"` to use the model.\n→ do `?PCA` for documentation."
":name" = "PCA"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:maxoutdim, :method, :pratio, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Float64\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.AdaBoostStumpClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.AdaBoostStumpClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ada-boosted stump classifier.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load AdaBoostStumpClassifier pkg=\"DecisionTree\"` to use the model.\n→ do `?AdaBoostStumpClassifier` for documentation."
":name" = "AdaBoostStumpClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:n_iter, :pdf_smoothing)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.DecisionTreeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.DecisionTreeRegressor"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "CART decision tree regressor.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load DecisionTreeRegressor pkg=\"DecisionTree\"` to use the model.\n→ do `?DecisionTreeRegressor` for documentation."
":name" = "DecisionTreeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :post_prune, :merge_purity_threshold, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.DecisionTreeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.DecisionTreeClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "CART decision tree classifier.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load DecisionTreeClassifier pkg=\"DecisionTree\"` to use the model.\n→ do `?DecisionTreeClassifier` for documentation."
":name" = "DecisionTreeClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :post_prune, :merge_purity_threshold, :pdf_smoothing, :display_depth, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Float64\", \"Float64\", \"Int64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.RandomForestRegressor"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Random forest regressor.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load RandomForestRegressor pkg=\"DecisionTree\"` to use the model.\n→ do `?RandomForestRegressor` for documentation."
":name" = "RandomForestRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :n_trees, :sampling_fraction, :pdf_smoothing, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:Union{AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Count, AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s41\"} where var\"_s41\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.RandomForestClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Random forest classifier.\n→ based on [DecisionTree](https://github.com/bensadeghi/DecisionTree.jl).\n→ do `@load RandomForestClassifier pkg=\"DecisionTree\"` to use the model.\n→ do `?RandomForestClassifier` for documentation."
":name" = "RandomForestClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :n_trees, :sampling_fraction, :pdf_smoothing, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[Clustering.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "Clustering"
":package_license" = "MIT"
":load_path" = "MLJClusteringInterface.KMeans"
":package_uuid" = "aaaa29a8-35af-508c-8bc3-b662a17a0fe5"
":package_url" = "https://github.com/JuliaStats/Clustering.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Means algorithm: find K centroids corresponding to K clusters in the data.   \n\n→ based on [Clustering](https://github.com/JuliaStats/Clustering.jl).\n→ do `@load KMeans pkg=\"Clustering\"` to use the model.\n→ do `?KMeans` for documentation."
":name" = "KMeans"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric)`"
":hyperparameter_types" = "`(\"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[Clustering.KMedoids]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "Clustering"
":package_license" = "MIT"
":load_path" = "MLJClusteringInterface.KMedoids"
":package_uuid" = "aaaa29a8-35af-508c-8bc3-b662a17a0fe5"
":package_url" = "https://github.com/JuliaStats/Clustering.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Medoids algorithm: find K centroids corresponding to K clusters in the data.\nUnlike K-Means, the centroids are found among data points themselves.\n\n→ based on [Clustering](https://github.com/JuliaStats/Clustering.jl).\n→ do `@load KMedoids pkg=\"Clustering\"` to use the model.\n→ do `?KMedoids` for documentation."
":name" = "KMedoids"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":predict", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric)`"
":hyperparameter_types" = "`(\"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostCount]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Count}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostCount"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Count` univariate targets, using a Poisson objective function. "
":name" = "XGBoostCount"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostRegressor"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Continuous` univariate targets. "
":name" = "XGBoostRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostClassifier"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Finite` univariate targets (`Multiclass`, `OrderedFactor` and `Binary=Finite{2}`)."
":name" = "XGBoostClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LightGBM.LGBMClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9344\"} where var\"_s9344\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9344\"} where var\"_s9344\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9344\"} where var\"_s9344\"<:ScientificTypesBase.Finite, AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LightGBM"
":package_license" = "MIT Expat"
":load_path" = "LightGBM.MLJInterface.LGBMClassifier"
":package_uuid" = "7acf609c-83a4-11e9-1ffb-b912bcd3b04a"
":package_url" = "https://github.com/IQVIA-ML/LightGBM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Microsoft LightGBM FFI wrapper: Classifier\n→ based on [LightGBM](https://github.com/IQVIA-ML/LightGBM.jl).\n→ do `@load LGBMClassifier pkg=\"LightGBM\"` to use the model.\n→ do `?LGBMClassifier` for documentation."
":name" = "LGBMClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":predict", ":update", ":fit"]
":hyperparameters" = "`(:boosting, :num_iterations, :learning_rate, :num_leaves, :max_depth, :tree_learner, :histogram_pool_size, :min_data_in_leaf, :min_sum_hessian_in_leaf, :max_delta_step, :lambda_l1, :lambda_l2, :min_gain_to_split, :feature_fraction, :feature_fraction_bynode, :feature_fraction_seed, :bagging_fraction, :pos_bagging_fraction, :neg_bagging_fraction, :bagging_freq, :bagging_seed, :early_stopping_round, :extra_trees, :extra_seed, :max_bin, :bin_construct_sample_cnt, :init_score, :drop_rate, :max_drop, :skip_drop, :xgboost_dart_mode, :uniform_drop, :drop_seed, :top_rate, :other_rate, :min_data_per_group, :max_cat_threshold, :cat_l2, :cat_smooth, :objective, :categorical_feature, :data_random_seed, :is_sparse, :is_unbalance, :boost_from_average, :scale_pos_weight, :use_missing, :feature_pre_filter, :metric, :metric_freq, :is_training_metric, :ndcg_at, :num_machines, :num_threads, :local_listen_port, :time_out, :machine_list_file, :save_binary, :device_type, :force_col_wise, :force_row_wise, :truncate_booster)`"
":hyperparameter_types" = "`(\"String\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Int64\", \"Int64\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"String\", \"Vector{Int64}\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Any\", \"Bool\", \"Bool\", \"Vector{String}\", \"Int64\", \"Bool\", \"Vector{Int64}\", \"Int64\", \"Int64\", \"Int64\", \"Int64\", \"String\", \"Bool\", \"String\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LightGBM.LGBMRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}, Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}, AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LightGBM"
":package_license" = "MIT Expat"
":load_path" = "LightGBM.MLJInterface.LGBMRegressor"
":package_uuid" = "7acf609c-83a4-11e9-1ffb-b912bcd3b04a"
":package_url" = "https://github.com/IQVIA-ML/LightGBM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Microsoft LightGBM FFI wrapper: Regressor\n→ based on [LightGBM](https://github.com/IQVIA-ML/LightGBM.jl).\n→ do `@load LGBMRegressor pkg=\"LightGBM\"` to use the model.\n→ do `?LGBMRegressor` for documentation."
":name" = "LGBMRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":update", ":fit"]
":hyperparameters" = "`(:boosting, :num_iterations, :learning_rate, :num_leaves, :max_depth, :tree_learner, :histogram_pool_size, :min_data_in_leaf, :min_sum_hessian_in_leaf, :max_delta_step, :lambda_l1, :lambda_l2, :min_gain_to_split, :feature_fraction, :feature_fraction_bynode, :feature_fraction_seed, :bagging_fraction, :bagging_freq, :bagging_seed, :early_stopping_round, :extra_trees, :extra_seed, :max_bin, :bin_construct_sample_cnt, :init_score, :drop_rate, :max_drop, :skip_drop, :xgboost_dart_mode, :uniform_drop, :drop_seed, :top_rate, :other_rate, :min_data_per_group, :max_cat_threshold, :cat_l2, :cat_smooth, :objective, :categorical_feature, :data_random_seed, :is_sparse, :is_unbalance, :boost_from_average, :use_missing, :feature_pre_filter, :alpha, :metric, :metric_freq, :is_training_metric, :ndcg_at, :num_machines, :num_threads, :local_listen_port, :time_out, :machine_list_file, :save_binary, :device_type, :force_col_wise, :force_row_wise, :truncate_booster)`"
":hyperparameter_types" = "`(\"String\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Int64\", \"Int64\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"String\", \"Vector{Int64}\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Float64\", \"Vector{String}\", \"Int64\", \"Bool\", \"Vector{Int64}\", \"Int64\", \"Int64\", \"Int64\", \"Int64\", \"String\", \"Bool\", \"String\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.AEDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.AEDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "AEDetector from OutlierDetectionNetworks.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl)."
":name" = "AEDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :loss)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Integer\", \"Integer\", \"Bool\", \"Bool\", \"Any\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.DSADDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.DSADDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "DSADDetector from OutlierDetectionNetworks.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl)."
":name" = "DSADDetector"
":is_supervised" = "`true`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.SupervisedDetector`"
":implemented_methods" = [":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :loss, :eta, :eps, :callback)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Tuple{Integer, Integer}\", \"Tuple{Integer, Integer}\", \"Tuple{Bool, Bool}\", \"Tuple{Bool, Bool}\", \"Any\", \"Function\", \"Number\", \"Number\", \"Tuple{Function, Function}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.ESADDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.ESADDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "ESADDetector from OutlierDetectionNetworks.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl)."
":name" = "ESADDetector"
":is_supervised" = "`true`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.SupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :λ1, :λ2, :noise)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Integer\", \"Integer\", \"Bool\", \"Bool\", \"Any\", \"Number\", \"Number\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeClassifier]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeClassifier"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multi-classification with softmax and cross-entropy loss.\n→ based on [EvoTrees](https://github.com/Evovest/EvoTrees.jl).\n→ do `@load EvoTreeClassifier pkg=\"EvoTrees\"` to use the model.\n→ do `?EvoTreeClassifier` for documentation."
":name" = "EvoTreeClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeGaussian]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeGaussian"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gaussian maximum likelihood of μ and σ.\n→ based on [EvoTrees](https://github.com/Evovest/EvoTrees.jl).\n→ do `@load EvoTreeGaussian pkg=\"EvoTrees\"` to use the model.\n→ do `?EvoTreeGaussian` for documentation."
":name" = "EvoTreeGaussian"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeRegressor]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeRegressor"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression models with various underlying methods: least square, quantile, logistic.\n→ based on [EvoTrees](https://github.com/Evovest/EvoTrees.jl).\n→ do `@load EvoTreeRegressor pkg=\"EvoTrees\"` to use the model.\n→ do `?EvoTreeRegressor` for documentation."
":name" = "EvoTreeRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeCount]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Count`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Count}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Count}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeCount"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Poisson regression fitting λ with max likelihood.\n→ based on [EvoTrees](https://github.com/Evovest/EvoTrees.jl).\n→ do `@load EvoTreeCount pkg=\"EvoTrees\"` to use the model.\n→ do `?EvoTreeCount` for documentation."
":name" = "EvoTreeCount"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ConstantClassifier]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite, AbstractVector{Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ConstantClassifier"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant classifier (Probabilistic).\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load ConstantClassifier pkg=\"MLJModels\"` to use the model.\n→ do `?ConstantClassifier` for documentation."
":name" = "ConstantClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":fit"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.Standardizer]
":input_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s259\"} where var\"_s259\"<:ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table, AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s259\"} where var\"_s259\"<:ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.Standardizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Standardize (whiten) features (columns) of a table.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load Standardizer pkg=\"MLJModels\"` to use the model.\n→ do `?Standardizer` for documentation."
":name" = "Standardizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:features, :ignore, :ordered_factor, :count)`"
":hyperparameter_types" = "`(\"Union{Function, AbstractVector{Symbol}}\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.DeterministicConstantClassifier]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.DeterministicConstantClassifier"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant classifier (Deterministic).\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load DeterministicConstantClassifier pkg=\"MLJModels\"` to use the model.\n→ do `?DeterministicConstantClassifier` for documentation."
":name" = "DeterministicConstantClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateTimeTypeToContinuous]
":input_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.ScientificTimeType`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.ScientificTimeType}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.ScientificTimeType`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateTimeTypeToContinuous"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Transform univariate data with element scitype `ScientificDateTime` so that it has `Continuous` element scitype, according to a learned scale. \n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load UnivariateTimeTypeToContinuous pkg=\"MLJModels\"` to use the model.\n→ do `?UnivariateTimeTypeToContinuous` for documentation."
":name" = "UnivariateTimeTypeToContinuous"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":transform"]
":hyperparameters" = "`(:zero_time, :step)`"
":hyperparameter_types" = "`(\"Union{Nothing, Dates.TimeType}\", \"Dates.Period\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.OneHotEncoder]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.OneHotEncoder"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "One-hot encode `Finite` (categorical) features (columns) of a table.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load OneHotEncoder pkg=\"MLJModels\"` to use the model.\n→ do `?OneHotEncoder` for documentation."
":name" = "OneHotEncoder"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":transform"]
":hyperparameters" = "`(:features, :drop_last, :ordered_factor, :ignore)`"
":hyperparameter_types" = "`(\"Vector{Symbol}\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ContinuousEncoder]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ContinuousEncoder"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Convert all `Finite` (categorical) and `Count` features (columns) of a table to `Continuous` and drop all  remaining non-`Continuous` features. \n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load ContinuousEncoder pkg=\"MLJModels\"` to use the model.\n→ do `?ContinuousEncoder` for documentation."
":name" = "ContinuousEncoder"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:drop_last, :one_hot_ordered_factors)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateBoxCoxTransformer]
":input_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateBoxCoxTransformer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Box-Cox transform univariate data.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load UnivariateBoxCoxTransformer pkg=\"MLJModels\"` to use the model.\n→ do `?UnivariateBoxCoxTransformer` for documentation."
":name" = "UnivariateBoxCoxTransformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:n, :shift)`"
":hyperparameter_types" = "`(\"Int64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ConstantRegressor]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Continuous}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ConstantRegressor"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant regressor (Probabilistic).\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load ConstantRegressor pkg=\"MLJModels\"` to use the model.\n→ do `?ConstantRegressor` for documentation."
":name" = "ConstantRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict"]
":hyperparameters" = "`(:distribution_type,)`"
":hyperparameter_types" = "`(\"Type{D} where D<:Distributions.Sampleable\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.FeatureSelector]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.FeatureSelector"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Filter features (columns) of a table by name.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load FeatureSelector pkg=\"MLJModels\"` to use the model.\n→ do `?FeatureSelector` for documentation."
":name" = "FeatureSelector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:features, :ignore)`"
":hyperparameter_types" = "`(\"Union{Function, Vector{Symbol}}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateDiscretizer]
":input_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous`"
":output_scitype" = "`AbstractVector{var\"_s259\"} where var\"_s259\"<:ScientificTypesBase.OrderedFactor`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s259\"} where var\"_s259\"<:ScientificTypesBase.OrderedFactor`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Continuous`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateDiscretizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Discretize a continuous variable via quantiles.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load UnivariateDiscretizer pkg=\"MLJModels\"` to use the model.\n→ do `?UnivariateDiscretizer` for documentation."
":name" = "UnivariateDiscretizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`(:n_classes,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.FillImputer]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.FillImputer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Imputes missing data with a fixed value computed on the non-missing values. A different imputing function can be specified for `Continuous`, `Count` and `Finite` data. \n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load FillImputer pkg=\"MLJModels\"` to use the model.\n→ do `?FillImputer` for documentation."
":name" = "FillImputer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:features, :continuous_fill, :count_fill, :finite_fill)`"
":hyperparameter_types" = "`(\"Vector{Symbol}\", \"Function\", \"Function\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.DeterministicConstantRegressor]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.DeterministicConstantRegressor"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant regressor (Deterministic).\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load DeterministicConstantRegressor pkg=\"MLJModels\"` to use the model.\n→ do `?DeterministicConstantRegressor` for documentation."
":name" = "DeterministicConstantRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateStandardizer]
":input_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Infinite`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Infinite}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s466\"} where var\"_s466\"<:ScientificTypesBase.Infinite`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateStandardizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Standardize (whiten) univariate data.\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load UnivariateStandardizer pkg=\"MLJModels\"` to use the model.\n→ do `?UnivariateStandardizer` for documentation."
":name" = "UnivariateStandardizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":inverse_transform", ":fit", ":transform"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateFillImputer]
":input_scitype" = "`Union{AbstractVector{var\"_s466\"} where var\"_s466\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s259\"} where var\"_s259\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":output_scitype" = "`Union{AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s217\"} where var\"_s217\"<:ScientificTypesBase.Count, AbstractVector{var\"_s4\"} where var\"_s4\"<:ScientificTypesBase.Finite}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{AbstractVector{var\"_s466\"} where var\"_s466\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s259\"} where var\"_s259\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Finite}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{AbstractVector{var\"_s222\"} where var\"_s222\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s217\"} where var\"_s217\"<:ScientificTypesBase.Count, AbstractVector{var\"_s4\"} where var\"_s4\"<:ScientificTypesBase.Finite}`"
":inverse_transform_scitype" = "`Union{AbstractVector{var\"_s466\"} where var\"_s466\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s259\"} where var\"_s259\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateFillImputer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Univariate form of FillImpututer. Imputes missing data with a fixed value computed on the non-missing values. A different imputing function can be specified for `Continuous`, `Count` and `Finite` data. \n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load UnivariateFillImputer pkg=\"MLJModels\"` to use the model.\n→ do `?UnivariateFillImputer` for documentation."
":name" = "UnivariateFillImputer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:continuous_fill, :count_fill, :finite_fill)`"
":hyperparameter_types" = "`(\"Function\", \"Function\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.MCDDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.MCDDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "MCDDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "MCDDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:store_precision, :assume_centered, :support_fraction, :random_state)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Union{Nothing, Real}\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.COPODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.COPODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "COPODDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "COPODDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.HBOSDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.HBOSDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "HBOSDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "HBOSDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_bins, :alpha, :tol)`"
":hyperparameter_types" = "`(\"Integer\", \"Real\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.IForestDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.IForestDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "IForestDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "IForestDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_estimators, :max_samples, :max_features, :bootstrap, :behaviour, :random_state, :verbose, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"Union{Real, String}\", \"Real\", \"Bool\", \"String\", \"Union{Nothing, Integer}\", \"Integer\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.SOSDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.SOSDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "SOSDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "SOSDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:perplexity, :metric, :eps)`"
":hyperparameter_types" = "`(\"Real\", \"String\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.ABODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.ABODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "ABODDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "ABODDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_neighbors, :method)`"
":hyperparameter_types" = "`(\"Integer\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LOFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LOFDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "LOFDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_neighbors, :algorithm, :leaf_size, :metric, :p, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Integer\", \"String\", \"Union{Nothing, Integer}\", \"Any\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.PCADetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.PCADetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "PCADetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "PCADetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_components, :n_selected_components, :copy, :whiten, :svd_solver, :tol, :iterated_power, :standardization, :weighted, :random_state)`"
":hyperparameter_types" = "`(\"Union{Nothing, Real}\", \"Union{Nothing, Integer}\", \"Bool\", \"Bool\", \"String\", \"Real\", \"Union{Integer, String}\", \"Bool\", \"Bool\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.OCSVMDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.OCSVMDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "OCSVMDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "OCSVMDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:kernel, :degree, :gamma, :coef0, :tol, :nu, :shrinking, :cache_size, :verbose, :max_iter)`"
":hyperparameter_types" = "`(\"String\", \"Integer\", \"Union{Real, String}\", \"Real\", \"Real\", \"Real\", \"Bool\", \"Integer\", \"Bool\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.SODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.SODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "SODDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "SODDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_neighbors, :ref_set, :alpha)`"
":hyperparameter_types" = "`(\"Integer\", \"Integer\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LODADetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LODADetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LODADetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "LODADetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_bins, :n_random_cuts)`"
":hyperparameter_types" = "`(\"Integer\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.KNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.KNNDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "KNNDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "KNNDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_neighbors, :method, :radius, :algorithm, :leaf_size, :metric, :p, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Real\", \"String\", \"Integer\", \"String\", \"Union{Nothing, Integer}\", \"Any\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.COFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.COFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "COFDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "COFDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_neighbors,)`"
":hyperparameter_types" = "`(\"Integer\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.CBLOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.CBLOFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "CBLOFDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "CBLOFDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_clusters, :alpha, :beta, :use_weights, :random_state, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"Real\", \"Real\", \"Bool\", \"Union{Nothing, Integer}\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LOCIDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LOCIDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LOCIDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "LOCIDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:alpha, :k)`"
":hyperparameter_types" = "`(\"Real\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LMDDDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LMDDDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LMDDDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "LMDDDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:n_iter, :dis_measure, :random_state)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.RODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:Union{Missing, ScientificTypesBase.OrderedFactor{2}}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.RODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "RODDetector from OutlierDetectionPython.jl.\n[Documentation](https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl)."
":name" = "RODDetector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":fit", ":reformat", ":selectrows", ":transform"]
":hyperparameters" = "`(:parallel_execution,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.EpsilonSVR]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.EpsilonSVR"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "EpsilonSVR from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "EpsilonSVR"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :gamma, :epsilon, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.LinearSVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.LinearSVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "LinearSVC from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "LinearSVC"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:solver, :weights, :tolerance, :cost, :p, :bias)`"
":hyperparameter_types" = "`(\"LIBSVM.Linearsolver.LINEARSOLVER\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Float64\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.NuSVR]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.NuSVR"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "NuSVR from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "NuSVR"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :gamma, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.NuSVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.NuSVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "NuSVC from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "NuSVC"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :gamma, :weights, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.SVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6462\"} where var\"_s6462\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.SVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "SVC from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "SVC"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":predict", ":fit"]
":hyperparameters" = "`(:kernel, :gamma, :weights, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking, :probability)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.OneClassSVM]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Binary`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Binary`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.OneClassSVM"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "OneClassSVM from LIBSVM.jl.\n[Documentation](https://github.com/mpastell/LIBSVM.jl)."
":name" = "OneClassSVM"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":transform"]
":hyperparameters" = "`(:kernel, :gamma, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[TSVD.TSVDTransformer]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":inverse_transform_scitype" = "`Union{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":is_pure_julia" = "`true`"
":package_name" = "TSVD"
":package_license" = "MIT"
":load_path" = "MLJTSVDInterface.TSVDTransformer"
":package_uuid" = "9449cd9e-2762-5aa3-a617-5413e99d722e"
":package_url" = "https://github.com/JuliaLinearAlgebra/TSVD.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Truncated SVD dimensionality reduction\n→ based on [TSVD](https://github.com/JuliaLinearAlgebra/TSVD.jl).\n→ do `@load TSVDTransformer pkg=\"TSVD\"` to use the model.\n→ do `?TSVDTransformer` for documentation."
":name" = "TSVDTransformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fitted_params", ":fit", ":transform"]
":hyperparameters" = "`(:nvals, :maxiter)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearBinaryClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Binary`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s6489\"} where var\"_s6489\"<:ScientificTypesBase.Binary}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Binary}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearBinaryClassifier"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear binary classifier with specified link (e.g. logistic).\n→ based on [GLM](https://github.com/JuliaStats/GLM.jl).\n→ do `@load LinearBinaryClassifier pkg=\"GLM\"` to use the model.\n→ do `?LinearBinaryClassifier` for documentation."
":name" = "LinearBinaryClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":predict_mean", ":fit"]
":hyperparameters" = "`(:fit_intercept, :link, :offsetcol)`"
":hyperparameter_types" = "`(\"Bool\", \"GLM.Link01\", \"Union{Nothing, Symbol}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearCountRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Count}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Count}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearCountRegressor"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear count regressor with specified link and distribution (e.g. log link and poisson).\n→ based on [GLM](https://github.com/JuliaStats/GLM.jl).\n→ do `@load LinearCountRegressor pkg=\"GLM\"` to use the model.\n→ do `?LinearCountRegressor` for documentation."
":name" = "LinearCountRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict", ":fit"]
":hyperparameters" = "`(:fit_intercept, :distribution, :link, :offsetcol)`"
":hyperparameter_types" = "`(\"Bool\", \"Distributions.Distribution\", \"GLM.Link\", \"Union{Nothing, Symbol}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Continuous}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearRegressor"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear regressor (OLS) with a Normal model.\n→ based on [GLM](https://github.com/JuliaStats/GLM.jl).\n→ do `@load LinearRegressor pkg=\"GLM\"` to use the model.\n→ do `?LinearRegressor` for documentation."
":name" = "LinearRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict", ":predict_mean", ":fit"]
":hyperparameters" = "`(:fit_intercept, :allowrankdeficient, :offsetcol)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Union{Nothing, Symbol}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJFlux.MultitargetNeuralNetworkRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.MultitargetNeuralNetworkRegressor"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making deterministic predictions of a `Continuous` multi-target, presented as a table, given a table of `Continuous` features. \n→ based on [MLJFlux](https://github.com/alan-turing-institute/MLJFlux.jl).\n→ do `@load MultitargetNeuralNetworkRegressor pkg=\"MLJFlux\"` to use the model.\n→ do `?MultitargetNeuralNetworkRegressor` for documentation."
":name" = "MultitargetNeuralNetworkRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.NeuralNetworkClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.NeuralNetworkClassifier"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making probabilistic predictions of a `Multiclass` or `OrderedFactor` target, given a table of `Continuous` features. \n→ based on [MLJFlux](https://github.com/alan-turing-institute/MLJFlux.jl).\n→ do `@load NeuralNetworkClassifier pkg=\"MLJFlux\"` to use the model.\n→ do `?NeuralNetworkClassifier` for documentation."
":name" = "NeuralNetworkClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :finaliser, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Int64, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.ImageClassifier]
":input_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Image`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9826\"} where var\"_s9826\"<:ScientificTypesBase.Multiclass`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Image, AbstractVector{var\"_s9826\"} where var\"_s9826\"<:ScientificTypesBase.Multiclass}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Multiclass}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.ImageClassifier"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making probabilistic predictions of a `GrayImage` target, given a table of `Continuous` features. \n→ based on [MLJFlux](https://github.com/alan-turing-institute/MLJFlux.jl).\n→ do `@load ImageClassifier pkg=\"MLJFlux\"` to use the model.\n→ do `?ImageClassifier` for documentation."
":name" = "ImageClassifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :finaliser, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Int64, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.NeuralNetworkRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s53\"} where var\"_s53\"<:(AbstractVector{var\"_s52\"} where var\"_s52\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s9827\"} where var\"_s9827\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.NeuralNetworkRegressor"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making deterministic predictions of a `Continuous` target, given a table of `Continuous` features. \n→ based on [MLJFlux](https://github.com/alan-turing-institute/MLJFlux.jl).\n→ do `@load NeuralNetworkRegressor pkg=\"MLJFlux\"` to use the model.\n→ do `?NeuralNetworkRegressor` for documentation."
":name" = "NeuralNetworkRegressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"
