
[BetaML.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.RandomForestRegressor"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Random Forest ensemble for regression with support for Missing data, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "RandomForestRegressor"
":human_name" = "random forest regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:nTrees, :maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :β, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Float64\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:Union{Missing, ScientificTypesBase.Finite}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s149\"} where var\"_s149\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.RandomForestClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Random Forest ensemble for classification with support for Missing data, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "RandomForestClassifier"
":human_name" = "random forest classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:nTrees, :maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :β, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Float64\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.PerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.PerceptronClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The classical perceptron algorithm using one-vs-all for multiclass, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "PerceptronClassifier"
":human_name" = "perceptron classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:initialθ, :initialθ₀, :maxEpochs, :shuffle, :forceOrigin, :returnMeanHyperplane, :rng)`"
":hyperparameter_types" = "`(\"Vector{Float64}\", \"Float64\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.DecisionTreeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.DecisionTreeRegressor"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Decision Tree for regression with support for Missing data, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "DecisionTreeRegressor"
":human_name" = "decision tree regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.PegasosClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.PegasosClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The gradient-based linear \"pegasos\" classifier using one-vs-all for multiclass, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "PegasosClassifier"
":human_name" = "pegasos classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:initialθ, :initialθ₀, :λ, :η, :maxEpochs, :shuffle, :forceOrigin, :returnMeanHyperplane, :rng)`"
":hyperparameter_types" = "`(\"Vector{Float64}\", \"Float64\", \"Float64\", \"Function\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KMedoids]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s149\", N} where {var\"_s149\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.KMedoids"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The K-medoids clustering algorithm with customisable distance function, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "KMedoids"
":human_name" = "k medoids"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:K, :dist, :initStrategy, :Z₀, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Function\", \"String\", \"Union{Nothing, Matrix{Float64}}\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s149\", N} where {var\"_s149\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.KMeans"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The classical KMeans clustering algorithm, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "KMeans"
":human_name" = "k means"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:K, :dist, :initStrategy, :Z₀, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Function\", \"String\", \"Union{Nothing, Matrix{Float64}}\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.DecisionTreeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known})`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:Union{Missing, ScientificTypesBase.Finite}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Known}), AbstractVector{var\"_s149\"} where var\"_s149\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Trees.DecisionTreeClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A simple Decision Tree for classification with support for Missing data, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "DecisionTreeClassifier"
":human_name" = "decision tree classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:maxDepth, :minGain, :minRecords, :maxFeatures, :splittingCriterion, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Function\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.GMMClusterer]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":output_scitype" = "`AbstractArray{var\"_s149\", N} where {var\"_s149\"<:ScientificTypesBase.Multiclass, N}`"
":target_scitype" = "`AbstractArray{var\"_s148\", N} where {var\"_s148\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractArray{var\"_s149\", N} where {var\"_s149\"<:ScientificTypesBase.Multiclass, N}`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.GMMClusterer"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Expectation-Maximisation clustering algorithm with customisable mixtures, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "GMMClusterer"
":human_name" = "gmm clusterer"
":is_supervised" = "`false`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:K, :p₀, :mixtures, :tol, :minVariance, :minCovariance, :initStrategy, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, AbstractVector{Float64}}\", \"Symbol\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.MissingImputator]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:Union{Missing, ScientificTypesBase.Continuous})`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Clustering.MissingImputator"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Impute missing values using an Expectation-Maximisation clustering algorithm, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "MissingImputator"
":human_name" = "missing imputator"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":transform"]
":hyperparameters" = "`(:K, :p₀, :mixtures, :tol, :minVariance, :minCovariance, :initStrategy, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, AbstractVector{Float64}}\", \"Symbol\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[BetaML.KernelPerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Infinite), AbstractVector{var\"_s149\"} where var\"_s149\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "BetaML"
":package_license" = "MIT"
":load_path" = "BetaML.Perceptron.KernelPerceptronClassifier"
":package_uuid" = "024491cd-cc6b-443e-8034-08ea7eb7db2b"
":package_url" = "https://github.com/sylvaticus/BetaML.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The kernel perceptron algorithm using one-vs-one for multiclass, from the Beta Machine Learning Toolkit (BetaML)."
":name" = "KernelPerceptronClassifier"
":human_name" = "kernel perceptron classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`(:K, :maxEpochs, :initialα, :shuffle, :rng)`"
":hyperparameter_types" = "`(\"Function\", \"Int64\", \"Vector{Int64}\", \"Bool\", \"Random.AbstractRNG\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.KNNClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s82\"} where var\"_s82\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s82\"} where var\"_s82\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s82\"} where var\"_s82\"<:ScientificTypesBase.Finite, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.KNNClassifier"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors classifier: predicts the class associated with a new point\nby taking a vote over the classes of the K-nearest points.\n"
":name" = "KNNClassifier"
":human_name" = "knn classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.MultitargetKNNClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Finite)`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Finite)}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Finite), AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Density{ScientificTypesBase.Finite})`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.MultitargetKNNClassifier"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors classifier: predicts the class associated with a new point\nby taking a vote over the classes of the K-nearest points.\n"
":name" = "MultitargetKNNClassifier"
":human_name" = "multitarget knn classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":predict_mode"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights, :output_type)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\", \"Type{var\\\"_s10\\\"} where var\\\"_s10\\\"<:Union{AbstractDict{K, V} where {K<:Symbol, V<:(AbstractVector{T} where T)}, NamedTuple{names, T} where {N, D, names, T<:Tuple{Vararg{AbstractArray{S, D} where S, N}}}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.MultitargetKNNRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.MultitargetKNNRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors regressor: predicts the response associated with a new point\nby taking an weighted average of the response of the K-nearest points.\n"
":name" = "MultitargetKNNRegressor"
":human_name" = "multitarget knn regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NearestNeighborModels.KNNRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NearestNeighborModels"
":package_license" = "MIT"
":load_path" = "NearestNeighborModels.KNNRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/alan-turing-institute/NearestNeighborModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Nearest Neighbors regressor: predicts the response associated with a new point\nby taking an weighted average of the response of the K-nearest points.\n"
":name" = "KNNRegressor"
":human_name" = "knn regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:K, :algorithm, :metric, :leafsize, :reorder, :weights)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Distances.Metric\", \"Int64\", \"Bool\", \"NearestNeighborModels.KNNKernel\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.ABODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.ABODDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nABODDetector(k = 5,\n             metric = Euclidean(),\n             algorithm = :kdtree,\n             static = :auto,\n             leafsize = 10,\n             reorder = true,\n             parallel = false,\n             enhanced = false)\n```\n\nDetermine outliers based on the angles to its nearest neighbors. This implements the `FastABOD` variant described in the paper, that is, it uses the variance of angles to its nearest neighbors, not to the whole dataset, see [1]. \n\n*Notice:* The scores are inverted, to conform to our notion that higher scores describe higher outlierness.\n\n## Parameters\n\n```\nk::Integer\n```\n\nNumber of neighbors (must be greater than 0).\n\n```\nmetric::Metric\n```\n\nThis is one of the Metric types defined in the Distances.jl package. It is possible to define your own metrics by creating new types that are subtypes of Metric.\n\n```\nalgorithm::Symbol\n```\n\nOne of `(:kdtree, :balltree)`. In a `kdtree`, points are recursively split into groups using hyper-planes. Therefore a KDTree only works with axis aligned metrics which are: Euclidean, Chebyshev, Minkowski and Cityblock. A *brutetree* linearly searches all points in a brute force fashion and works with any Metric. A *balltree* recursively splits points into groups bounded by hyper-spheres and works with any Metric.\n\n```\nstatic::Union{Bool, Symbol}\n```\n\nOne of `(true, false, :auto)`. Whether the input data for fitting and transform should be statically or dynamically allocated. If `true`, the data is statically allocated. If `false`, the data is dynamically allocated. If `:auto`, the data is dynamically allocated if the product of all dimensions except the last is greater than 100.\n\n```\nleafsize::Int\n```\n\nDetermines at what number of points to stop splitting the tree further. There is a trade-off between traversing the tree and having to evaluate the metric function for increasing number of points.\n\n```\nreorder::Bool\n```\n\nWhile building the tree this will put points close in distance close in memory since this helps with cache locality. In this case, a copy of the original data will be made so that the original data is left unmodified. This can have a significant impact on performance and is by default set to true.\n\n```\nparallel::Bool\n```\n\nParallelize `score` and `predict` using all threads available. The number of threads can be set with the `JULIA_NUM_THREADS` environment variable. Note: `fit` is not parallel.\n\n```\nenhanced::Bool\n```\n\nWhen `enhanced=true`, it uses the enhanced ABOD (EABOD) adaptation proposed by [2].\n\n## Examples\n\n```julia\nusing OutlierDetection: ABODDetector, fit, score\ndetector = ABODDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Kriegel, Hans-Peter; S hubert, Matthias; Zimek, Arthur (2008): Angle-based outlier detection in high-dimensional data.\n\n[2] Li, Xiaojie; Lv, Jian Cheng; Cheng, Dongdong (2015): Angle-Based Outlier Detection Algorithm with More Stable Relationships.\n"
":name" = "ABODDetector"
":human_name" = "abod detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :static, :leafsize, :reorder, :parallel, :enhanced)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Union{Bool, Symbol}\", \"Integer\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.DNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.DNNDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDNNDetector(d = 0,\n            metric = Euclidean(),\n            algorithm = :kdtree,\n            leafsize = 10,\n            reorder = true,\n            parallel = false)\n```\n\nAnomaly score based on the number of neighbors in a hypersphere of radius `d`. Knorr et al. [1] directly converted the resulting outlier scores to labels, thus this implementation does not fully reflect the approach from the paper.\n\n## Parameters\n\n```\nd::Real\n```\n\nThe hypersphere radius used to calculate the global density of an instance.\n\n```\nmetric::Metric\n```\n\nThis is one of the Metric types defined in the Distances.jl package. It is possible to define your own metrics by creating new types that are subtypes of Metric.\n\n```\nalgorithm::Symbol\n```\n\nOne of `(:kdtree, :balltree)`. In a `kdtree`, points are recursively split into groups using hyper-planes. Therefore a KDTree only works with axis aligned metrics which are: Euclidean, Chebyshev, Minkowski and Cityblock. A *brutetree* linearly searches all points in a brute force fashion and works with any Metric. A *balltree* recursively splits points into groups bounded by hyper-spheres and works with any Metric.\n\n```\nstatic::Union{Bool, Symbol}\n```\n\nOne of `(true, false, :auto)`. Whether the input data for fitting and transform should be statically or dynamically allocated. If `true`, the data is statically allocated. If `false`, the data is dynamically allocated. If `:auto`, the data is dynamically allocated if the product of all dimensions except the last is greater than 100.\n\n```\nleafsize::Int\n```\n\nDetermines at what number of points to stop splitting the tree further. There is a trade-off between traversing the tree and having to evaluate the metric function for increasing number of points.\n\n```\nreorder::Bool\n```\n\nWhile building the tree this will put points close in distance close in memory since this helps with cache locality. In this case, a copy of the original data will be made so that the original data is left unmodified. This can have a significant impact on performance and is by default set to true.\n\n```\nparallel::Bool\n```\n\nParallelize `score` and `predict` using all threads available. The number of threads can be set with the `JULIA_NUM_THREADS` environment variable. Note: `fit` is not parallel.\n\n## Examples\n\n```julia\nusing OutlierDetection: DNNDetector, fit, score\ndetector = DNNDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Knorr, Edwin M.; Ng, Raymond T. (1998): Algorithms for Mining Distance-Based Outliers in Large Datasets.\n"
":name" = "DNNDetector"
":human_name" = "dnn detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:metric, :algorithm, :static, :leafsize, :reorder, :parallel, :d)`"
":hyperparameter_types" = "`(\"Distances.Metric\", \"Symbol\", \"Union{Bool, Symbol}\", \"Integer\", \"Bool\", \"Bool\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.LOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.LOFDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLOFDetector(k = 5,\n            metric = Euclidean(),\n            algorithm = :kdtree,\n            leafsize = 10,\n            reorder = true,\n            parallel = false)\n```\n\nCalculate an anomaly score based on the density of an instance in comparison to its neighbors. This algorithm introduced the notion of local outliers and was developed by Breunig et al., see [1].\n\n## Parameters\n\n```\nk::Integer\n```\n\nNumber of neighbors (must be greater than 0).\n\n```\nmetric::Metric\n```\n\nThis is one of the Metric types defined in the Distances.jl package. It is possible to define your own metrics by creating new types that are subtypes of Metric.\n\n```\nalgorithm::Symbol\n```\n\nOne of `(:kdtree, :balltree)`. In a `kdtree`, points are recursively split into groups using hyper-planes. Therefore a KDTree only works with axis aligned metrics which are: Euclidean, Chebyshev, Minkowski and Cityblock. A *brutetree* linearly searches all points in a brute force fashion and works with any Metric. A *balltree* recursively splits points into groups bounded by hyper-spheres and works with any Metric.\n\n```\nstatic::Union{Bool, Symbol}\n```\n\nOne of `(true, false, :auto)`. Whether the input data for fitting and transform should be statically or dynamically allocated. If `true`, the data is statically allocated. If `false`, the data is dynamically allocated. If `:auto`, the data is dynamically allocated if the product of all dimensions except the last is greater than 100.\n\n```\nleafsize::Int\n```\n\nDetermines at what number of points to stop splitting the tree further. There is a trade-off between traversing the tree and having to evaluate the metric function for increasing number of points.\n\n```\nreorder::Bool\n```\n\nWhile building the tree this will put points close in distance close in memory since this helps with cache locality. In this case, a copy of the original data will be made so that the original data is left unmodified. This can have a significant impact on performance and is by default set to true.\n\n```\nparallel::Bool\n```\n\nParallelize `score` and `predict` using all threads available. The number of threads can be set with the `JULIA_NUM_THREADS` environment variable. Note: `fit` is not parallel.\n\n## Examples\n\n```julia\nusing OutlierDetection: LOFDetector, fit, score\ndetector = LOFDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Breunig, Markus M.; Kriegel, Hans-Peter; Ng, Raymond T.; Sander, Jörg (2000): LOF: Identifying Density-Based Local Outliers.\n"
":name" = "LOFDetector"
":human_name" = "lof detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :static, :leafsize, :reorder, :parallel)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Union{Bool, Symbol}\", \"Integer\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.KNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.KNNDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nKNNDetector(k=5,\n            metric=Euclidean,\n            algorithm=:kdtree,\n            leafsize=10,\n            reorder=true,\n            reduction=:maximum)\n```\n\nCalculate the anomaly score of an instance based on the distance to its k-nearest neighbors.\n\n## Parameters\n\n```\nk::Integer\n```\n\nNumber of neighbors (must be greater than 0).\n\n```\nmetric::Metric\n```\n\nThis is one of the Metric types defined in the Distances.jl package. It is possible to define your own metrics by creating new types that are subtypes of Metric.\n\n```\nalgorithm::Symbol\n```\n\nOne of `(:kdtree, :balltree)`. In a `kdtree`, points are recursively split into groups using hyper-planes. Therefore a KDTree only works with axis aligned metrics which are: Euclidean, Chebyshev, Minkowski and Cityblock. A *brutetree* linearly searches all points in a brute force fashion and works with any Metric. A *balltree* recursively splits points into groups bounded by hyper-spheres and works with any Metric.\n\n```\nstatic::Union{Bool, Symbol}\n```\n\nOne of `(true, false, :auto)`. Whether the input data for fitting and transform should be statically or dynamically allocated. If `true`, the data is statically allocated. If `false`, the data is dynamically allocated. If `:auto`, the data is dynamically allocated if the product of all dimensions except the last is greater than 100.\n\n```\nleafsize::Int\n```\n\nDetermines at what number of points to stop splitting the tree further. There is a trade-off between traversing the tree and having to evaluate the metric function for increasing number of points.\n\n```\nreorder::Bool\n```\n\nWhile building the tree this will put points close in distance close in memory since this helps with cache locality. In this case, a copy of the original data will be made so that the original data is left unmodified. This can have a significant impact on performance and is by default set to true.\n\n```\nparallel::Bool\n```\n\nParallelize `score` and `predict` using all threads available. The number of threads can be set with the `JULIA_NUM_THREADS` environment variable. Note: `fit` is not parallel.\n\n```\nreduction::Symbol\n```\n\nOne of `(:maximum, :median, :mean)`. (`reduction=:maximum`) was proposed by [1]. Angiulli et al. [2] proposed sum to reduce the distances, but mean has been implemented for numerical stability.\n\n## Examples\n\n```julia\nusing OutlierDetection: KNNDetector, fit, score\ndetector = KNNDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Ramaswamy, Sridhar; Rastogi, Rajeev; Shim, Kyuseok (2000): Efficient Algorithms for Mining Outliers from Large Data Sets.\n\n[2] Angiulli, Fabrizio; Pizzuti, Clara (2002): Fast Outlier Detection in High Dimensional Spaces.\n"
":name" = "KNNDetector"
":human_name" = "knn detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :static, :leafsize, :reorder, :parallel, :reduction)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Union{Bool, Symbol}\", \"Integer\", \"Bool\", \"Bool\", \"Symbol\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNeighbors.COFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNeighbors"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNeighbors.COFDetector"
":package_uuid" = "51249a0a-cb36-4849-8e04-30c7f8d311bb"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNeighbors.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nCOFDetector(k = 5,\n            metric = Euclidean(),\n            algorithm = :kdtree,\n            leafsize = 10,\n            reorder = true,\n            parallel = false)\n```\n\nLocal outlier density based on chaining distance between graphs of neighbors, as described in [1].\n\n## Parameters\n\n```\nk::Integer\n```\n\nNumber of neighbors (must be greater than 0).\n\n```\nmetric::Metric\n```\n\nThis is one of the Metric types defined in the Distances.jl package. It is possible to define your own metrics by creating new types that are subtypes of Metric.\n\n```\nalgorithm::Symbol\n```\n\nOne of `(:kdtree, :balltree)`. In a `kdtree`, points are recursively split into groups using hyper-planes. Therefore a KDTree only works with axis aligned metrics which are: Euclidean, Chebyshev, Minkowski and Cityblock. A *brutetree* linearly searches all points in a brute force fashion and works with any Metric. A *balltree* recursively splits points into groups bounded by hyper-spheres and works with any Metric.\n\n```\nstatic::Union{Bool, Symbol}\n```\n\nOne of `(true, false, :auto)`. Whether the input data for fitting and transform should be statically or dynamically allocated. If `true`, the data is statically allocated. If `false`, the data is dynamically allocated. If `:auto`, the data is dynamically allocated if the product of all dimensions except the last is greater than 100.\n\n```\nleafsize::Int\n```\n\nDetermines at what number of points to stop splitting the tree further. There is a trade-off between traversing the tree and having to evaluate the metric function for increasing number of points.\n\n```\nreorder::Bool\n```\n\nWhile building the tree this will put points close in distance close in memory since this helps with cache locality. In this case, a copy of the original data will be made so that the original data is left unmodified. This can have a significant impact on performance and is by default set to true.\n\n```\nparallel::Bool\n```\n\nParallelize `score` and `predict` using all threads available. The number of threads can be set with the `JULIA_NUM_THREADS` environment variable. Note: `fit` is not parallel.\n\n## Examples\n\n```julia\nusing OutlierDetection: COFDetector, fit, score\ndetector = COFDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Tang, Jian; Chen, Zhixiang; Fu, Ada Wai-Chee; Cheung, David Wai-Lok (2002): Enhancing Effectiveness of Outlier Detections for Low Density Patterns.\n"
":name" = "COFDetector"
":human_name" = "cof detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:k, :metric, :algorithm, :static, :leafsize, :reorder, :parallel)`"
":hyperparameter_types" = "`(\"Integer\", \"Distances.Metric\", \"Symbol\", \"Union{Bool, Symbol}\", \"Integer\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[PartialLeastSquaresRegressor.KPLSRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "PartialLeastSquaresRegressor"
":package_license" = "MIT"
":load_path" = "PartialLeastSquaresRegressor.KPLSRegressor"
":package_uuid" = "f4b1acfe-f311-436c-bb79-8483f53c17d5"
":package_url" = "https://github.com/lalvim/PartialLeastSquaresRegressor.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Kernel Partial Least Squares Regressor. A Kernel PLS2 NIPALS algorithms. Can be used mainly for regression."
":name" = "KPLSRegressor"
":human_name" = "kpls regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:n_factors, :kernel, :width)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[PartialLeastSquaresRegressor.PLSRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s85\"} where var\"_s85\"<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "PartialLeastSquaresRegressor"
":package_license" = "MIT"
":load_path" = "PartialLeastSquaresRegressor.PLSRegressor"
":package_uuid" = "f4b1acfe-f311-436c-bb79-8483f53c17d5"
":package_url" = "https://github.com/lalvim/PartialLeastSquaresRegressor.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A Partial Least Squares Regressor. Contains PLS1, PLS2 (multi target) algorithms. Can be used mainly for regression."
":name" = "PLSRegressor"
":human_name" = "pls regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:n_factors,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.QuantileRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.QuantileRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Quantile Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load QuantileRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?QuantileRegressor` for documentation."
":name" = "QuantileRegressor"
":human_name" = "quantile regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:delta, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LogisticClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s93\"} where var\"_s93\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s93\"} where var\"_s93\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LogisticClassifier"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Classifier corresponding to the loss function ``L(y, Xθ) + λ|θ|₂²/2 + γ|θ|₁`` where `L` is the logistic loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LogisticClassifier pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LogisticClassifier` for documentation."
":name" = "LogisticClassifier"
":human_name" = "logistic classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.MultinomialClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s93\"} where var\"_s93\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s93\"} where var\"_s93\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.MultinomialClassifier"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Classifier corresponding to the loss function ``L(y, Xθ) + λ|θ|₂²/2 + γ|θ|₁`` where `L` is the multinomial loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load MultinomialClassifier pkg=\"MLJLinearModels\" to use the model.`\n→ do `?MultinomialClassifier` for documentation."
":name" = "MultinomialClassifier"
":human_name" = "multinomial classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LADRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LADRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Absolute Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LADRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LADRegressor` for documentation."
":name" = "LADRegressor"
":human_name" = "lad regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.RidgeRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₂²/2``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load RidgeRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?RidgeRegressor` for documentation."
":name" = "RidgeRegressor"
":human_name" = "ridge regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.RobustRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.RobustRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` for a given robust `ρ`.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load RobustRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?RobustRegressor` for documentation."
":name" = "RobustRegressor"
":human_name" = "robust regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:rho, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"MLJLinearModels.RobustRho\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.ElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.ElasticNetRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₂²/2 + γ|θ|₁``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load ElasticNetRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?ElasticNetRegressor` for documentation."
":name" = "ElasticNetRegressor"
":human_name" = "elastic net regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :gamma, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LinearRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LinearRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LinearRegressor` for documentation."
":name" = "LinearRegressor"
":human_name" = "linear regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :solver)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.LassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.LassoRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression with objective function ``|Xθ - y|₂²/2 + λ|θ|₁``.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load LassoRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?LassoRegressor` for documentation."
":name" = "LassoRegressor"
":human_name" = "lasso regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJLinearModels.HuberRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJLinearModels"
":package_license" = "MIT"
":load_path" = "MLJLinearModels.HuberRegressor"
":package_uuid" = "6ee0df7b-362f-4a72-a706-9e79364fb692"
":package_url" = "https://github.com/alan-turing-institute/MLJLinearModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Robust regression with objective ``∑ρ(Xθ - y) + λ|θ|₂² + γ|θ|₁`` where `ρ` is the Huber Loss.\n→ based on [MLJLinearModels](https://github.com/alan-turing-institute/MLJLinearModels.jl)\n→ do `@load HuberRegressor pkg=\"MLJLinearModels\" to use the model.`\n→ do `?HuberRegressor` for documentation."
":name" = "HuberRegressor"
":human_name" = "huber regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:delta, :lambda, :gamma, :penalty, :fit_intercept, :penalize_intercept, :scale_penalty_with_samples, :solver)`"
":hyperparameter_types" = "`(\"Real\", \"Real\", \"Real\", \"Union{String, Symbol}\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, MLJLinearModels.Solver}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ProbabilisticSGDClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ProbabilisticSGDClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nProbabilisticSGDClassifier\n```\n\nModel type for probabilistic sgd classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nProbabilisticSGDClassifier = @load ProbabilisticSGDClassifier pkg=ScikitLearn\n```\n\nDo `model = ProbabilisticSGDClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`ProbabilisticSGDClassifier(loss=...)`.\n# Hyper-parameters\n\n- `loss = log`\n\n- `penalty = l2`\n\n- `alpha = 0.0001`\n\n- `l1_ratio = 0.15`\n\n- `fit_intercept = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.001`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `epsilon = 0.1`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `learning_rate = optimal`\n\n- `eta0 = 0.0`\n\n- `power_t = 0.5`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `class_weight = nothing`\n\n- `warm_start = false`\n\n- `average = false`\n\n"
":name" = "ProbabilisticSGDClassifier"
":human_name" = "probabilistic sgd classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :n_jobs, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeCVClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeCVClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRidgeCVClassifier\n```\n\nModel type for ridge regression classifier with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRidgeCVClassifier = @load RidgeCVClassifier pkg=ScikitLearn\n```\n\nDo `model = RidgeCVClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RidgeCVClassifier(alphas=...)`.\n# Hyper-parameters\n\n- `alphas = [0.1, 1.0, 10.0]`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `scoring = nothing`\n\n- `cv = 5`\n\n- `class_weight = nothing`\n\n- `store_cv_values = false`\n\n"
":name" = "RidgeCVClassifier"
":human_name" = "ridge regression classifier with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alphas, :fit_intercept, :normalize, :scoring, :cv, :class_weight, :store_cv_values)`"
":hyperparameter_types" = "`(\"AbstractArray{Float64, N} where N\", \"Bool\", \"Bool\", \"Any\", \"Int64\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LogisticClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LogisticClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLogisticClassifier\n```\n\nModel type for logistic regression classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLogisticClassifier = @load LogisticClassifier pkg=ScikitLearn\n```\n\nDo `model = LogisticClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LogisticClassifier(penalty=...)`.\n# Hyper-parameters\n\n- `penalty = l2`\n\n- `dual = false`\n\n- `tol = 0.0001`\n\n- `C = 1.0`\n\n- `fit_intercept = true`\n\n- `intercept_scaling = 1.0`\n\n- `class_weight = nothing`\n\n- `random_state = nothing`\n\n- `solver = lbfgs`\n\n- `max_iter = 100`\n\n- `multi_class = auto`\n\n- `verbose = 0`\n\n- `warm_start = false`\n\n- `n_jobs = nothing`\n\n- `l1_ratio = nothing`\n\n"
":name" = "LogisticClassifier"
":human_name" = "logistic regression classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:penalty, :dual, :tol, :C, :fit_intercept, :intercept_scaling, :class_weight, :random_state, :solver, :max_iter, :multi_class, :verbose, :warm_start, :n_jobs, :l1_ratio)`"
":hyperparameter_types" = "`(\"String\", \"Bool\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Any\", \"Any\", \"String\", \"Int64\", \"String\", \"Int64\", \"Bool\", \"Union{Nothing, Int64}\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RandomForestRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRandomForestRegressor\n```\n\nModel type for random forest regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRandomForestRegressor = @load RandomForestRegressor pkg=ScikitLearn\n```\n\nDo `model = RandomForestRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RandomForestRegressor(n_estimators=...)`.\n# Hyper-parameters\n\n- `n_estimators = 100`\n\n- `criterion = mse`\n\n- `max_depth = nothing`\n\n- `min_samples_split = 2`\n\n- `min_samples_leaf = 1`\n\n- `min_weight_fraction_leaf = 0.0`\n\n- `max_features = auto`\n\n- `max_leaf_nodes = nothing`\n\n- `min_impurity_decrease = 0.0`\n\n- `bootstrap = true`\n\n- `oob_score = false`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `verbose = 0`\n\n- `warm_start = false`\n\n- `ccp_alpha = 0.0`\n\n- `max_samples = nothing`\n\n"
":name" = "RandomForestRegressor"
":human_name" = "random forest regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :ccp_alpha, :max_samples)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Float64\", \"Union{Nothing, Float64, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ElasticNetCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ElasticNetCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nElasticNetCVRegressor\n```\n\nModel type for elastic net regression with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nElasticNetCVRegressor = @load ElasticNetCVRegressor pkg=ScikitLearn\n```\n\nDo `model = ElasticNetCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`ElasticNetCVRegressor(l1_ratio=...)`.\n# Hyper-parameters\n\n- `l1_ratio = 0.5`\n\n- `eps = 0.001`\n\n- `n_alphas = 100`\n\n- `alphas = nothing`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `precompute = auto`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `cv = 5`\n\n- `copy_X = true`\n\n- `verbose = 0`\n\n- `n_jobs = nothing`\n\n- `positive = false`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "ElasticNetCVRegressor"
":human_name" = "elastic net regression with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:l1_ratio, :eps, :n_alphas, :alphas, :fit_intercept, :normalize, :precompute, :max_iter, :tol, :cv, :copy_X, :verbose, :n_jobs, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PerceptronClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PerceptronClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nPerceptronClassifier\n```\n\nModel type for perceptron classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nPerceptronClassifier = @load PerceptronClassifier pkg=ScikitLearn\n```\n\nDo `model = PerceptronClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`PerceptronClassifier(penalty=...)`.\n# Hyper-parameters\n\n- `penalty = nothing`\n\n- `alpha = 0.0001`\n\n- `fit_intercept = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.001`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `eta0 = 1.0`\n\n- `n_jobs = nothing`\n\n- `random_state = 0`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `class_weight = nothing`\n\n- `warm_start = false`\n\n"
":name" = "PerceptronClassifier"
":human_name" = "perceptron classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:penalty, :alpha, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :eta0, :n_jobs, :random_state, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start)`"
":hyperparameter_types" = "`(\"Union{Nothing, String}\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskLassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskLassoRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultiTaskLassoRegressor\n```\n\nModel type for multi-target lasso regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultiTaskLassoRegressor = @load MultiTaskLassoRegressor pkg=ScikitLearn\n```\n\nDo `model = MultiTaskLassoRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MultiTaskLassoRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `copy_X = true`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "MultiTaskLassoRegressor"
":human_name" = "multi-target lasso regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :max_iter, :tol, :copy_X, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LinearRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLinearRegressor\n```\n\nModel type for ordinary least-squares regressor (OLS), based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLinearRegressor = @load LinearRegressor pkg=ScikitLearn\n```\n\nDo `model = LinearRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LinearRegressor(fit_intercept=...)`.\n# Hyper-parameters\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `copy_X = true`\n\n- `n_jobs = nothing`\n\n"
":name" = "LinearRegressor"
":human_name" = "ordinary least-squares regressor (OLS)"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :normalize, :copy_X, :n_jobs)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DBSCAN]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DBSCAN"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDBSCAN\n```\n\nModel type for dbscan, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nDBSCAN = @load DBSCAN pkg=ScikitLearn\n```\n\nDo `model = DBSCAN()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `DBSCAN(eps=...)`.\n\nDensity-Based Spatial Clustering of Applications with Noise. Finds core samples of high density and expands clusters from them. Good for data which contains clusters of similar density.\n"
":name" = "DBSCAN"
":human_name" = "dbscan"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params"]
":hyperparameters" = "`(:eps, :min_samples, :metric, :algorithm, :leaf_size, :p, :n_jobs)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"String\", \"String\", \"Int64\", \"Union{Nothing, Float64}\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRidgeRegressor\n```\n\nModel type for ridge regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRidgeRegressor = @load RidgeRegressor pkg=ScikitLearn\n```\n\nDo `model = RidgeRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RidgeRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `copy_X = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `solver = auto`\n\n- `random_state = nothing`\n\n"
":name" = "RidgeRegressor"
":human_name" = "ridge regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :solver, :random_state)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Bool\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsICRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsICRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLassoLarsICRegressor\n```\n\nModel type for Lasso model with LARS using BIC or AIC for model selection, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLassoLarsICRegressor = @load LassoLarsICRegressor pkg=ScikitLearn\n```\n\nDo `model = LassoLarsICRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LassoLarsICRegressor(criterion=...)`.\n# Hyper-parameters\n\n- `criterion = aic`\n\n- `fit_intercept = true`\n\n- `verbose = false`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n- `max_iter = 500`\n\n- `eps = 2.220446049250313e-16`\n\n- `copy_X = true`\n\n- `positive = false`\n\n"
":name" = "LassoLarsICRegressor"
":human_name" = "Lasso model with LARS using BIC or AIC for model selection"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:criterion, :fit_intercept, :verbose, :normalize, :precompute, :max_iter, :eps, :copy_X, :positive)`"
":hyperparameter_types" = "`(\"String\", \"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ARDRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ARDRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nARDRegressor\n```\n\nModel type for Bayesian ARD regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nARDRegressor = @load ARDRegressor pkg=ScikitLearn\n```\n\nDo `model = ARDRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`ARDRegressor(n_iter=...)`.\n# Hyper-parameters\n\n- `n_iter = 300`\n\n- `tol = 0.001`\n\n- `alpha_1 = 1.0e-6`\n\n- `alpha_2 = 1.0e-6`\n\n- `lambda_1 = 1.0e-6`\n\n- `lambda_2 = 1.0e-6`\n\n- `compute_score = false`\n\n- `threshold_lambda = 10000.0`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `copy_X = true`\n\n- `verbose = false`\n\n"
":name" = "ARDRegressor"
":human_name" = "Bayesian ARD regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_iter, :tol, :alpha_1, :alpha_2, :lambda_1, :lambda_2, :compute_score, :threshold_lambda, :fit_intercept, :normalize, :copy_X, :verbose)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMNuRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMNuRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMNuRegressor\n```\n\nModel type for nu-support vector regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMNuRegressor = @load SVMNuRegressor pkg=ScikitLearn\n```\n\nDo `model = SVMNuRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMNuRegressor(nu=...)`.\n# Hyper-parameters\n\n- `nu = 0.5`\n\n- `C = 1.0`\n\n- `kernel = rbf`\n\n- `degree = 3`\n\n- `gamma = auto`\n\n- `coef0 = 0.0`\n\n- `shrinking = true`\n\n- `tol = 0.001`\n\n- `cache_size = 200`\n\n- `max_iter = -1`\n\n"
":name" = "SVMNuRegressor"
":human_name" = "nu-support vector regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:nu, :C, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Any\", \"Float64\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRidgeClassifier\n```\n\nModel type for ridge regression classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRidgeClassifier = @load RidgeClassifier pkg=ScikitLearn\n```\n\nDo `model = RidgeClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RidgeClassifier(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `copy_X = true`\n\n- `max_iter = nothing`\n\n- `tol = 0.001`\n\n- `class_weight = nothing`\n\n- `solver = auto`\n\n- `random_state = nothing`\n\n"
":name" = "RidgeClassifier"
":human_name" = "ridge regression classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :class_weight, :solver, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Float64\", \"Any\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SGDRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SGDRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSGDRegressor\n```\n\nModel type for stochastic gradient descent-based regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSGDRegressor = @load SGDRegressor pkg=ScikitLearn\n```\n\nDo `model = SGDRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SGDRegressor(loss=...)`.\n# Hyper-parameters\n\n- `loss = squared_loss`\n\n- `penalty = l2`\n\n- `alpha = 0.0001`\n\n- `l1_ratio = 0.15`\n\n- `fit_intercept = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.001`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `epsilon = 0.1`\n\n- `random_state = nothing`\n\n- `learning_rate = invscaling`\n\n- `eta0 = 0.01`\n\n- `power_t = 0.25`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `warm_start = false`\n\n- `average = false`\n\n"
":name" = "SGDRegressor"
":human_name" = "stochastic gradient descent-based regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Union{Bool, Int64}\", \"Float64\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ComplementNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ComplementNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nComplementNBClassifier\n```\n\nModel type for Complement naive Bayes classifier, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nComplementNBClassifier = @load ComplementNBClassifier pkg=ScikitLearn\n```\n\nDo `model = ComplementNBClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `ComplementNBClassifier(alpha=...)`.\n\nSimilar to [`MultinomialNBClassifier`](@ref) but with more robust assumptions. Suited for imbalanced datasets.\n"
":name" = "ComplementNBClassifier"
":human_name" = "Complement naive Bayes classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_prior, :class_prior, :norm)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.HuberRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.HuberRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nHuberRegressor\n```\n\nModel type for Huber regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nHuberRegressor = @load HuberRegressor pkg=ScikitLearn\n```\n\nDo `model = HuberRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`HuberRegressor(epsilon=...)`.\n# Hyper-parameters\n\n- `epsilon = 1.35`\n\n- `max_iter = 100`\n\n- `alpha = 0.0001`\n\n- `warm_start = false`\n\n- `fit_intercept = true`\n\n- `tol = 1.0e-5`\n\n"
":name" = "HuberRegressor"
":human_name" = "Huber regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:epsilon, :max_iter, :alpha, :warm_start, :fit_intercept, :tol)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMNuClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMNuClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMNuClassifier\n```\n\nModel type for nu-support vector classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMNuClassifier = @load SVMNuClassifier pkg=ScikitLearn\n```\n\nDo `model = SVMNuClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMNuClassifier(nu=...)`.\n# Hyper-parameters\n\n- `nu = 0.5`\n\n- `kernel = rbf`\n\n- `degree = 3`\n\n- `gamma = auto`\n\n- `coef0 = 0.0`\n\n- `shrinking = true`\n\n- `tol = 0.001`\n\n- `cache_size = 200`\n\n- `max_iter = -1`\n\n- `decision_function_shape = ovr`\n\n- `random_state = nothing`\n\n"
":name" = "SVMNuClassifier"
":human_name" = "nu-support vector classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:nu, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter, :decision_function_shape, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GradientBoostingClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GradientBoostingClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGradientBoostingClassifier\n```\n\nModel type for gradient boosting classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGradientBoostingClassifier = @load GradientBoostingClassifier pkg=ScikitLearn\n```\n\nDo `model = GradientBoostingClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`GradientBoostingClassifier(loss=...)`.\n# Hyper-parameters\n\n- `loss = deviance`\n\n- `learning_rate = 0.1`\n\n- `n_estimators = 100`\n\n- `subsample = 1.0`\n\n- `criterion = friedman_mse`\n\n- `min_samples_split = 2`\n\n- `min_samples_leaf = 1`\n\n- `min_weight_fraction_leaf = 0.0`\n\n- `max_depth = 3`\n\n- `min_impurity_decrease = 0.0`\n\n- `init = nothing`\n\n- `random_state = nothing`\n\n- `max_features = nothing`\n\n- `verbose = 0`\n\n- `max_leaf_nodes = nothing`\n\n- `warm_start = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = nothing`\n\n- `tol = 0.0001`\n\n"
":name" = "GradientBoostingClassifier"
":human_name" = "gradient boosting classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:loss, :learning_rate, :n_estimators, :subsample, :criterion, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_depth, :min_impurity_decrease, :init, :random_state, :max_features, :verbose, :max_leaf_nodes, :warm_start, :validation_fraction, :n_iter_no_change, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Float64\", \"Int64\", \"Float64\", \"String\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Int64\", \"Float64\", \"Any\", \"Any\", \"Union{Nothing, Float64, Int64, String}\", \"Int64\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\", \"Union{Nothing, Int64}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianProcessRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianProcessRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGaussianProcessRegressor\n```\n\nModel type for Gaussian process regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGaussianProcessRegressor = @load GaussianProcessRegressor pkg=ScikitLearn\n```\n\nDo `model = GaussianProcessRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`GaussianProcessRegressor(kernel=...)`.\n# Hyper-parameters\n\n- `kernel = nothing`\n\n- `alpha = 1.0e-10`\n\n- `optimizer = fmin_l_bfgs_b`\n\n- `n_restarts_optimizer = 0`\n\n- `normalize_y = false`\n\n- `copy_X_train = true`\n\n- `random_state = nothing`\n\n"
":name" = "GaussianProcessRegressor"
":human_name" = "Gaussian process regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:kernel, :alpha, :optimizer, :n_restarts_optimizer, :normalize_y, :copy_X_train, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Union{Float64, AbstractArray}\", \"Any\", \"Int64\", \"Bool\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMLinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMLinearRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMLinearRegressor\n```\n\nModel type for linear support vector regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMLinearRegressor = @load SVMLinearRegressor pkg=ScikitLearn\n```\n\nDo `model = SVMLinearRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMLinearRegressor(epsilon=...)`.\n# Hyper-parameters\n\n- `epsilon = 0.0`\n\n- `tol = 0.0001`\n\n- `C = 1.0`\n\n- `loss = epsilon_insensitive`\n\n- `fit_intercept = true`\n\n- `intercept_scaling = 1.0`\n\n- `dual = true`\n\n- `random_state = nothing`\n\n- `max_iter = 1000`\n\n"
":name" = "SVMLinearRegressor"
":human_name" = "linear support vector regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:epsilon, :tol, :C, :loss, :fit_intercept, :intercept_scaling, :dual, :random_state, :max_iter)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Float64\", \"String\", \"Bool\", \"Float64\", \"Bool\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LarsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LarsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLarsRegressor\n```\n\nModel type for least angle regressor (LARS), based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLarsRegressor = @load LarsRegressor pkg=ScikitLearn\n```\n\nDo `model = LarsRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LarsRegressor(fit_intercept=...)`.\n# Hyper-parameters\n\n- `fit_intercept = true`\n\n- `verbose = false`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n- `n_nonzero_coefs = 500`\n\n- `eps = 2.220446049250313e-16`\n\n- `copy_X = true`\n\n- `fit_path = true`\n\n"
":name" = "LarsRegressor"
":human_name" = "least angle regressor (LARS)"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :verbose, :normalize, :precompute, :n_nonzero_coefs, :eps, :copy_X, :fit_path)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MeanShift]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MeanShift"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMeanShift\n```\n\nModel type for mean shift, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMeanShift = @load MeanShift pkg=ScikitLearn\n```\n\nDo `model = MeanShift()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `MeanShift(bandwidth=...)`.\n\nMean shift clustering using a flat kernel. Mean shift clustering aims to discover \"blobs\" in a smooth density of samples. It is a centroid-based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region. These candidates are then filtered in a post-processing stage to eliminate near-duplicates to form the final set of centroids.\"\n"
":name" = "MeanShift"
":human_name" = "mean shift"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:bandwidth, :seeds, :bin_seeding, :min_bin_freq, :cluster_all, :n_jobs)`"
":hyperparameter_types" = "`(\"Union{Nothing, Float64}\", \"Union{Nothing, AbstractArray}\", \"Bool\", \"Int64\", \"Bool\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AdaBoostRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AdaBoostRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAdaBoostRegressor\n```\n\nModel type for AdaBoost ensemble regression, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nAdaBoostRegressor = @load AdaBoostRegressor pkg=ScikitLearn\n```\n\nDo `model = AdaBoostRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`AdaBoostRegressor(base_estimator=...)`.\n# Hyper-parameters\n\n- `base_estimator = nothing`\n\n- `n_estimators = 50`\n\n- `learning_rate = 1.0`\n\n- `loss = linear`\n\n- `random_state = nothing`\n\n"
":name" = "AdaBoostRegressor"
":human_name" = "AdaBoost ensemble regression"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :learning_rate, :loss, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AffinityPropagation]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AffinityPropagation"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAffinityPropagation\n```\n\nModel type for Affinity Propagation Clustering of data, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nAffinityPropagation = @load AffinityPropagation pkg=ScikitLearn\n```\n\nDo `model = AffinityPropagation()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`AffinityPropagation(damping=...)`.\n# Hyper-parameters\n\n- `damping = 0.5`\n\n- `max_iter = 200`\n\n- `convergence_iter = 15`\n\n- `copy = true`\n\n- `preference = nothing`\n\n- `affinity = euclidean`\n\n- `verbose = false`\n\n"
":name" = "AffinityPropagation"
":human_name" = "Affinity Propagation Clustering of data"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:damping, :max_iter, :convergence_iter, :copy, :preference, :affinity, :verbose)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Int64\", \"Bool\", \"Any\", \"String\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskLassoCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskLassoCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultiTaskLassoCVRegressor\n```\n\nModel type for multi-target lasso regressor with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultiTaskLassoCVRegressor = @load MultiTaskLassoCVRegressor pkg=ScikitLearn\n```\n\nDo `model = MultiTaskLassoCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MultiTaskLassoCVRegressor(eps=...)`.\n# Hyper-parameters\n\n- `eps = 0.001`\n\n- `n_alphas = 100`\n\n- `alphas = nothing`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `max_iter = 300`\n\n- `tol = 0.0001`\n\n- `copy_X = true`\n\n- `cv = 5`\n\n- `verbose = false`\n\n- `n_jobs = 1`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "MultiTaskLassoCVRegressor"
":human_name" = "multi-target lasso regressor with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:eps, :n_alphas, :alphas, :fit_intercept, :normalize, :max_iter, :tol, :copy_X, :cv, :verbose, :n_jobs, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OrthogonalMatchingPursuitRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OrthogonalMatchingPursuitRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nOrthogonalMatchingPursuitRegressor\n```\n\nModel type for orthogonal matching pursuit regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nOrthogonalMatchingPursuitRegressor = @load OrthogonalMatchingPursuitRegressor pkg=ScikitLearn\n```\n\nDo `model = OrthogonalMatchingPursuitRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`OrthogonalMatchingPursuitRegressor(n_nonzero_coefs=...)`.\n# Hyper-parameters\n\n- `n_nonzero_coefs = nothing`\n\n- `tol = nothing`\n\n- `fit_intercept = true`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n"
":name" = "OrthogonalMatchingPursuitRegressor"
":human_name" = "orthogonal matching pursuit regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_nonzero_coefs, :tol, :fit_intercept, :normalize, :precompute)`"
":hyperparameter_types" = "`(\"Union{Nothing, Int64}\", \"Union{Nothing, Float64}\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RidgeCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RidgeCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRidgeCVRegressor\n```\n\nModel type for ridge regressor with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRidgeCVRegressor = @load RidgeCVRegressor pkg=ScikitLearn\n```\n\nDo `model = RidgeCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RidgeCVRegressor(alphas=...)`.\n# Hyper-parameters\n\n- `alphas = (0.1, 1.0, 10.0)`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `scoring = nothing`\n\n- `cv = 5`\n\n- `gcv_mode = nothing`\n\n- `store_cv_values = false`\n\n"
":name" = "RidgeCVRegressor"
":human_name" = "ridge regressor with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alphas, :fit_intercept, :normalize, :scoring, :cv, :gcv_mode, :store_cv_values)`"
":hyperparameter_types" = "`(\"Any\", \"Bool\", \"Bool\", \"Any\", \"Any\", \"Union{Nothing, String}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PassiveAggressiveClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PassiveAggressiveClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nPassiveAggressiveClassifier\n```\n\nModel type for passive aggressive classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nPassiveAggressiveClassifier = @load PassiveAggressiveClassifier pkg=ScikitLearn\n```\n\nDo `model = PassiveAggressiveClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`PassiveAggressiveClassifier(C=...)`.\n# Hyper-parameters\n\n- `C = 1.0`\n\n- `fit_intercept = true`\n\n- `max_iter = 100`\n\n- `tol = 0.001`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `loss = hinge`\n\n- `n_jobs = nothing`\n\n- `random_state = 0`\n\n- `warm_start = false`\n\n- `class_weight = nothing`\n\n- `average = false`\n\n"
":name" = "PassiveAggressiveClassifier"
":human_name" = "passive aggressive classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:C, :fit_intercept, :max_iter, :tol, :early_stopping, :validation_fraction, :n_iter_no_change, :shuffle, :verbose, :loss, :n_jobs, :random_state, :warm_start, :class_weight, :average)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Any\", \"Bool\", \"Any\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMRegressor\n```\n\nModel type for epsilon-support vector regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMRegressor = @load SVMRegressor pkg=ScikitLearn\n```\n\nDo `model = SVMRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMRegressor(kernel=...)`.\n# Hyper-parameters\n\n- `kernel = rbf`\n\n- `degree = 3`\n\n- `gamma = auto`\n\n- `coef0 = 0.0`\n\n- `tol = 0.001`\n\n- `C = 1.0`\n\n- `epsilon = 0.1`\n\n- `shrinking = true`\n\n- `cache_size = 200`\n\n- `max_iter = -1`\n\n"
":name" = "SVMRegressor"
":human_name" = "epsilon-support vector regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:kernel, :degree, :gamma, :coef0, :tol, :C, :epsilon, :shrinking, :cache_size, :max_iter)`"
":hyperparameter_types" = "`(\"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BernoulliNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BernoulliNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBernoulliNBClassifier\n```\n\nModel type for Bernoulli naive Bayes classifier, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBernoulliNBClassifier = @load BernoulliNBClassifier pkg=ScikitLearn\n```\n\nDo `model = BernoulliNBClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `BernoulliNBClassifier(alpha=...)`.\n\nBinomial naive bayes classifier. It is suitable for classification with binary features; features will be binarized based on the `binarize` keyword (unless it's `nothing` in which case the features are assumed to be binary).\n"
":name" = "BernoulliNBClassifier"
":human_name" = "Bernoulli naive Bayes classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :binarize, :fit_prior, :class_prior)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Nothing, Float64}\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGaussianNBClassifier\n```\n\nModel type for Gaussian naive Bayes classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGaussianNBClassifier = @load GaussianNBClassifier pkg=ScikitLearn\n```\n\nDo `model = GaussianNBClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`GaussianNBClassifier(priors=...)`.\n# Hyper-parameters\n\n- `priors = nothing`\n\n- `var_smoothing = 1.0e-9`\n\n"
":name" = "GaussianNBClassifier"
":human_name" = "Gaussian naive Bayes classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:priors, :var_smoothing)`"
":hyperparameter_types" = "`(\"Union{Nothing, AbstractVector{Float64}}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ExtraTreesClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ExtraTreesClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nExtraTreesClassifier\n```\n\nModel type for extra trees classifier, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nExtraTreesClassifier = @load ExtraTreesClassifier pkg=ScikitLearn\n```\n\nDo `model = ExtraTreesClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `ExtraTreesClassifier(n_estimators=...)`.\n\nExtra trees classifier, fits a number of randomized decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.\n"
":name" = "ExtraTreesClassifier"
":human_name" = "extra trees classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :class_weight)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KMeans"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nKMeans\n```\n\nModel type for k means, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nKMeans = @load KMeans pkg=ScikitLearn\n```\n\nDo `model = KMeans()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `KMeans(n_clusters=...)`.\n\nK-Means algorithm: find K centroids corresponding to K clusters in the data.\n"
":name" = "KMeans"
":human_name" = "k means"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:n_clusters, :n_init, :max_iter, :tol, :verbose, :random_state, :copy_x, :algorithm, :init)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"String\", \"Union{String, AbstractArray}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskElasticNetCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskElasticNetCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultiTaskElasticNetCVRegressor\n```\n\nModel type for multi-target elastic net regressor with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultiTaskElasticNetCVRegressor = @load MultiTaskElasticNetCVRegressor pkg=ScikitLearn\n```\n\nDo `model = MultiTaskElasticNetCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MultiTaskElasticNetCVRegressor(l1_ratio=...)`.\n# Hyper-parameters\n\n- `l1_ratio = 0.5`\n\n- `eps = 0.001`\n\n- `n_alphas = 100`\n\n- `alphas = nothing`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `cv = 5`\n\n- `copy_X = true`\n\n- `verbose = 0`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "MultiTaskElasticNetCVRegressor"
":human_name" = "multi-target elastic net regressor with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:l1_ratio, :eps, :n_alphas, :alphas, :fit_intercept, :normalize, :max_iter, :tol, :cv, :copy_X, :verbose, :n_jobs, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Union{Float64, Vector{Float64}}\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLassoLarsCVRegressor\n```\n\nModel type for Lasso model fit with least angle regression (LARS) with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLassoLarsCVRegressor = @load LassoLarsCVRegressor pkg=ScikitLearn\n```\n\nDo `model = LassoLarsCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LassoLarsCVRegressor(fit_intercept=...)`.\n# Hyper-parameters\n\n- `fit_intercept = true`\n\n- `verbose = false`\n\n- `max_iter = 500`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n- `cv = 5`\n\n- `max_n_alphas = 1000`\n\n- `n_jobs = nothing`\n\n- `eps = 2.220446049250313e-16`\n\n- `copy_X = true`\n\n- `positive = false`\n\n"
":name" = "LassoLarsCVRegressor"
":human_name" = "Lasso model fit with least angle regression (LARS) with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :verbose, :max_iter, :normalize, :precompute, :cv, :max_n_alphas, :n_jobs, :eps, :copy_X, :positive)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Int64\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Any\", \"Int64\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OrthogonalMatchingPursuitCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OrthogonalMatchingPursuitCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nOrthogonalMatchingPursuitCVRegressor\n```\n\nModel type for orthogonal ,atching pursuit (OMP) model with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nOrthogonalMatchingPursuitCVRegressor = @load OrthogonalMatchingPursuitCVRegressor pkg=ScikitLearn\n```\n\nDo `model = OrthogonalMatchingPursuitCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`OrthogonalMatchingPursuitCVRegressor(copy=...)`.\n# Hyper-parameters\n\n- `copy = true`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `max_iter = nothing`\n\n- `cv = 5`\n\n- `n_jobs = 1`\n\n- `verbose = false`\n\n"
":name" = "OrthogonalMatchingPursuitCVRegressor"
":human_name" = "orthogonal ,atching pursuit (OMP) model with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:copy, :fit_intercept, :normalize, :max_iter, :cv, :n_jobs, :verbose)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Union{Nothing, Int64}\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AdaBoostClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AdaBoostClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAdaBoostClassifier\n```\n\nModel type for ada boost classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nAdaBoostClassifier = @load AdaBoostClassifier pkg=ScikitLearn\n```\n\nDo `model = AdaBoostClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`AdaBoostClassifier(base_estimator=...)`.\n# Hyper-parameters\n\n- `base_estimator = nothing`\n\n- `n_estimators = 50`\n\n- `learning_rate = 1.0`\n\n- `algorithm = SAMME.R`\n\n- `random_state = nothing`\n\n"
":name" = "AdaBoostClassifier"
":human_name" = "ada boost classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :learning_rate, :algorithm, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Float64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.PassiveAggressiveRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.PassiveAggressiveRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nPassiveAggressiveRegressor\n```\n\nModel type for passive aggressive regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nPassiveAggressiveRegressor = @load PassiveAggressiveRegressor pkg=ScikitLearn\n```\n\nDo `model = PassiveAggressiveRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`PassiveAggressiveRegressor(C=...)`.\n# Hyper-parameters\n\n- `C = 1.0`\n\n- `fit_intercept = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `loss = epsilon_insensitive`\n\n- `epsilon = 0.1`\n\n- `random_state = nothing`\n\n- `warm_start = false`\n\n- `average = false`\n\n"
":name" = "PassiveAggressiveRegressor"
":human_name" = "passive aggressive regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:C, :fit_intercept, :max_iter, :tol, :early_stopping, :validation_fraction, :n_iter_no_change, :shuffle, :verbose, :loss, :epsilon, :random_state, :warm_start, :average)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Bool\", \"Union{Bool, Int64}\", \"String\", \"Float64\", \"Any\", \"Bool\", \"Union{Bool, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianRidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianRidgeRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBayesianRidgeRegressor\n```\n\nModel type for Bayesian ridge regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBayesianRidgeRegressor = @load BayesianRidgeRegressor pkg=ScikitLearn\n```\n\nDo `model = BayesianRidgeRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`BayesianRidgeRegressor(n_iter=...)`.\n# Hyper-parameters\n\n- `n_iter = 300`\n\n- `tol = 0.001`\n\n- `alpha_1 = 1.0e-6`\n\n- `alpha_2 = 1.0e-6`\n\n- `lambda_1 = 1.0e-6`\n\n- `lambda_2 = 1.0e-6`\n\n- `compute_score = false`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `copy_X = true`\n\n- `verbose = false`\n\n"
":name" = "BayesianRidgeRegressor"
":human_name" = "Bayesian ridge regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_iter, :tol, :alpha_1, :alpha_2, :lambda_1, :lambda_2, :compute_score, :fit_intercept, :normalize, :copy_X, :verbose)`"
":hyperparameter_types" = "`(\"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RANSACRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RANSACRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRANSACRegressor\n```\n\nModel type for ransac regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRANSACRegressor = @load RANSACRegressor pkg=ScikitLearn\n```\n\nDo `model = RANSACRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RANSACRegressor(base_estimator=...)`.\n# Hyper-parameters\n\n- `base_estimator = nothing`\n\n- `min_samples = 5`\n\n- `residual_threshold = nothing`\n\n- `is_data_valid = nothing`\n\n- `is_model_valid = nothing`\n\n- `max_trials = 100`\n\n- `max_skips = 9223372036854775807`\n\n- `stop_n_inliers = 9223372036854775807`\n\n- `stop_score = Inf`\n\n- `stop_probability = 0.99`\n\n- `loss = absolute_loss`\n\n- `random_state = nothing`\n\n"
":name" = "RANSACRegressor"
":human_name" = "ransac regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:base_estimator, :min_samples, :residual_threshold, :is_data_valid, :is_model_valid, :max_trials, :max_skips, :stop_n_inliers, :stop_score, :stop_probability, :loss, :random_state)`"
":hyperparameter_types" = "`(\"Any\", \"Union{Float64, Int64}\", \"Union{Nothing, Float64}\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Function, String}\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BaggingClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BaggingClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBaggingClassifier\n```\n\nModel type for bagging ensemble classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBaggingClassifier = @load BaggingClassifier pkg=ScikitLearn\n```\n\nDo `model = BaggingClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`BaggingClassifier(base_estimator=...)`.\n# Hyper-parameters\n\n- `base_estimator = nothing`\n\n- `n_estimators = 10`\n\n- `max_samples = 1.0`\n\n- `max_features = 1.0`\n\n- `bootstrap = true`\n\n- `bootstrap_features = false`\n\n- `oob_score = false`\n\n- `warm_start = false`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `verbose = 0`\n\n"
":name" = "BaggingClassifier"
":human_name" = "bagging ensemble classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :max_samples, :max_features, :bootstrap, :bootstrap_features, :oob_score, :warm_start, :n_jobs, :random_state, :verbose)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GaussianProcessClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GaussianProcessClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGaussianProcessClassifier\n```\n\nModel type for Gaussian process classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGaussianProcessClassifier = @load GaussianProcessClassifier pkg=ScikitLearn\n```\n\nDo `model = GaussianProcessClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`GaussianProcessClassifier(kernel=...)`.\n# Hyper-parameters\n\n- `kernel = nothing`\n\n- `optimizer = fmin_l_bfgs_b`\n\n- `n_restarts_optimizer = 0`\n\n- `copy_X_train = true`\n\n- `random_state = nothing`\n\n- `max_iter_predict = 100`\n\n- `warm_start = false`\n\n- `multi_class = one_vs_rest`\n\n"
":name" = "GaussianProcessClassifier"
":human_name" = "Gaussian process classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:kernel, :optimizer, :n_restarts_optimizer, :copy_X_train, :random_state, :max_iter_predict, :warm_start, :multi_class)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Int64\", \"Bool\", \"Any\", \"Int64\", \"Bool\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.OPTICS]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.OPTICS"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nOPTICS\n```\n\nModel type for optics, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nOPTICS = @load OPTICS pkg=ScikitLearn\n```\n\nDo `model = OPTICS()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `OPTICS(min_samples=...)`.\n\nOPTICS (Ordering Points To Identify the Clustering Structure), closely related to [`DBSCAN'](@ref), finds core sample of high density and expands clusters from them. Unlike DBSCAN, keeps cluster hierarchy for a variable neighborhood radius. Better suited for usage on large datasets than the current sklearn implementation of DBSCAN.\n"
":name" = "OPTICS"
":human_name" = "optics"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params"]
":hyperparameters" = "`(:min_samples, :max_eps, :metric, :p, :cluster_method, :eps, :xi, :predecessor_correction, :min_cluster_size, :algorithm, :leaf_size, :n_jobs)`"
":hyperparameter_types" = "`(\"Union{Float64, Int64}\", \"Float64\", \"String\", \"Int64\", \"String\", \"Union{Nothing, Float64}\", \"Float64\", \"Bool\", \"Union{Nothing, Float64, Int64}\", \"String\", \"Int64\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KNeighborsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KNeighborsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nKNeighborsRegressor\n```\n\nModel type for K-nearest neighbors regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nKNeighborsRegressor = @load KNeighborsRegressor pkg=ScikitLearn\n```\n\nDo `model = KNeighborsRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`KNeighborsRegressor(n_neighbors=...)`.\n# Hyper-parameters\n\n- `n_neighbors = 5`\n\n- `weights = uniform`\n\n- `algorithm = auto`\n\n- `leaf_size = 30`\n\n- `p = 2`\n\n- `metric = minkowski`\n\n- `metric_params = nothing`\n\n- `n_jobs = nothing`\n\n"
":name" = "KNeighborsRegressor"
":human_name" = "K-nearest neighbors regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_neighbors, :weights, :algorithm, :leaf_size, :p, :metric, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Function, String}\", \"String\", \"Int64\", \"Int64\", \"Any\", \"Any\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MiniBatchKMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MiniBatchKMeans"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMiniBatchKMeans\n```\n\nModel type for Mini-Batch K-Means clustering., based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMiniBatchKMeans = @load MiniBatchKMeans pkg=ScikitLearn\n```\n\nDo `model = MiniBatchKMeans()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MiniBatchKMeans(n_clusters=...)`.\n# Hyper-parameters\n\n- `n_clusters = 8`\n\n- `max_iter = 100`\n\n- `batch_size = 100`\n\n- `verbose = 0`\n\n- `compute_labels = true`\n\n- `random_state = nothing`\n\n- `tol = 0.0`\n\n- `max_no_improvement = 10`\n\n- `init_size = nothing`\n\n- `n_init = 3`\n\n- `init = k-means++`\n\n- `reassignment_ratio = 0.01`\n\n"
":name" = "MiniBatchKMeans"
":human_name" = "Mini-Batch K-Means clustering."
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:n_clusters, :max_iter, :batch_size, :verbose, :compute_labels, :random_state, :tol, :max_no_improvement, :init_size, :n_init, :init, :reassignment_ratio)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Any\", \"Float64\", \"Int64\", \"Union{Nothing, Int64}\", \"Int64\", \"Union{String, AbstractArray}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLassoCVRegressor\n```\n\nModel type for lasso regressor with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLassoCVRegressor = @load LassoCVRegressor pkg=ScikitLearn\n```\n\nDo `model = LassoCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LassoCVRegressor(eps=...)`.\n# Hyper-parameters\n\n- `eps = 0.001`\n\n- `n_alphas = 100`\n\n- `alphas = nothing`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `precompute = auto`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `copy_X = true`\n\n- `cv = 5`\n\n- `verbose = false`\n\n- `n_jobs = nothing`\n\n- `positive = false`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "LassoCVRegressor"
":human_name" = "lasso regressor with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:eps, :n_alphas, :alphas, :fit_intercept, :normalize, :precompute, :max_iter, :tol, :copy_X, :cv, :verbose, :n_jobs, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"Union{Bool, Int64}\", \"Union{Nothing, Int64}\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DummyRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DummyRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDummyRegressor\n```\n\nModel type for dummy regressor, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nDummyRegressor = @load DummyRegressor pkg=ScikitLearn\n```\n\nDo `model = DummyRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `DummyRegressor(strategy=...)`.\n\nDummyRegressor is a regressor that makes predictions using simple rules.\n"
":name" = "DummyRegressor"
":human_name" = "dummy regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:strategy, :constant, :quantile)`"
":hyperparameter_types" = "`(\"String\", \"Any\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoLarsRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoLarsRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLassoLarsRegressor\n```\n\nModel type for Lasso model fit with least angle regression (LARS), based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLassoLarsRegressor = @load LassoLarsRegressor pkg=ScikitLearn\n```\n\nDo `model = LassoLarsRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LassoLarsRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `fit_intercept = true`\n\n- `verbose = false`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n- `max_iter = 500`\n\n- `eps = 2.220446049250313e-16`\n\n- `copy_X = true`\n\n- `fit_path = true`\n\n- `positive = false`\n\n"
":name" = "LassoLarsRegressor"
":human_name" = "Lasso model fit with least angle regression (LARS)"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_intercept, :verbose, :normalize, :precompute, :max_iter, :eps, :copy_X, :fit_path, :positive)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Bool, Int64}\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LarsCVRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LarsCVRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLarsCVRegressor\n```\n\nModel type for least angle regressor with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLarsCVRegressor = @load LarsCVRegressor pkg=ScikitLearn\n```\n\nDo `model = LarsCVRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LarsCVRegressor(fit_intercept=...)`.\n# Hyper-parameters\n\n- `fit_intercept = true`\n\n- `verbose = false`\n\n- `max_iter = 500`\n\n- `normalize = true`\n\n- `precompute = auto`\n\n- `cv = 5`\n\n- `max_n_alphas = 1000`\n\n- `n_jobs = nothing`\n\n- `eps = 2.220446049250313e-16`\n\n- `copy_X = true`\n\n"
":name" = "LarsCVRegressor"
":human_name" = "least angle regressor with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :verbose, :max_iter, :normalize, :precompute, :cv, :max_n_alphas, :n_jobs, :eps, :copy_X)`"
":hyperparameter_types" = "`(\"Bool\", \"Union{Bool, Int64}\", \"Int64\", \"Bool\", \"Union{Bool, String, AbstractMatrix{T} where T}\", \"Any\", \"Int64\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.KNeighborsClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.KNeighborsClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nKNeighborsClassifier\n```\n\nModel type for K-nearest neighbors classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nKNeighborsClassifier = @load KNeighborsClassifier pkg=ScikitLearn\n```\n\nDo `model = KNeighborsClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`KNeighborsClassifier(n_neighbors=...)`.\n# Hyper-parameters\n\n- `n_neighbors = 5`\n\n- `weights = uniform`\n\n- `algorithm = auto`\n\n- `leaf_size = 30`\n\n- `p = 2`\n\n- `metric = minkowski`\n\n- `metric_params = nothing`\n\n- `n_jobs = nothing`\n\n"
":name" = "KNeighborsClassifier"
":human_name" = "K-nearest neighbors classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_neighbors, :weights, :algorithm, :leaf_size, :p, :metric, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Function, String}\", \"String\", \"Int64\", \"Int64\", \"Any\", \"Any\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMLinearClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMLinearClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMLinearClassifier\n```\n\nModel type for linear support vector classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMLinearClassifier = @load SVMLinearClassifier pkg=ScikitLearn\n```\n\nDo `model = SVMLinearClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMLinearClassifier(penalty=...)`.\n# Hyper-parameters\n\n- `penalty = l2`\n\n- `loss = squared_hinge`\n\n- `dual = true`\n\n- `tol = 0.0001`\n\n- `C = 1.0`\n\n- `multi_class = ovr`\n\n- `fit_intercept = true`\n\n- `intercept_scaling = 1.0`\n\n- `random_state = nothing`\n\n- `max_iter = 1000`\n\n"
":name" = "SVMLinearClassifier"
":human_name" = "linear support vector classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:penalty, :loss, :dual, :tol, :C, :multi_class, :fit_intercept, :intercept_scaling, :random_state, :max_iter)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Bool\", \"Float64\", \"Float64\", \"String\", \"Bool\", \"Float64\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.FeatureAgglomeration]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.FeatureAgglomeration"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nFeatureAgglomeration\n```\n\nModel type for feature agglomeration, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nFeatureAgglomeration = @load FeatureAgglomeration pkg=ScikitLearn\n```\n\nDo `model = FeatureAgglomeration()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `FeatureAgglomeration(n_clusters=...)`.\n\nSimilar to [`AgglomerativeClustering`](@ref), but recursively merges features instead of samples.\"\n"
":name" = "FeatureAgglomeration"
":human_name" = "feature agglomeration"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:n_clusters, :memory, :connectivity, :affinity, :compute_full_tree, :linkage, :distance_threshold)`"
":hyperparameter_types" = "`(\"Int64\", \"Any\", \"Any\", \"Any\", \"Union{Bool, String}\", \"String\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.DummyClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.DummyClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDummyClassifier\n```\n\nModel type for dummy classifier, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nDummyClassifier = @load DummyClassifier pkg=ScikitLearn\n```\n\nDo `model = DummyClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `DummyClassifier(strategy=...)`.\n\nDummyClassifier is a classifier that makes predictions using simple rules.\n"
":name" = "DummyClassifier"
":human_name" = "dummy classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:strategy, :constant, :random_state)`"
":hyperparameter_types" = "`(\"String\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BaggingRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BaggingRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBaggingRegressor\n```\n\nModel type for bagging ensemble regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBaggingRegressor = @load BaggingRegressor pkg=ScikitLearn\n```\n\nDo `model = BaggingRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`BaggingRegressor(base_estimator=...)`.\n# Hyper-parameters\n\n- `base_estimator = nothing`\n\n- `n_estimators = 10`\n\n- `max_samples = 1.0`\n\n- `max_features = 1.0`\n\n- `bootstrap = true`\n\n- `bootstrap_features = false`\n\n- `oob_score = false`\n\n- `warm_start = false`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `verbose = 0`\n\n"
":name" = "BaggingRegressor"
":human_name" = "bagging ensemble regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:base_estimator, :n_estimators, :max_samples, :max_features, :bootstrap, :bootstrap_features, :oob_score, :warm_start, :n_jobs, :random_state, :verbose)`"
":hyperparameter_types" = "`(\"Any\", \"Int64\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianQDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianQDA"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBayesianQDA\n```\n\nModel type for Bayesian quadratic discriminant analysis, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBayesianQDA = @load BayesianQDA pkg=ScikitLearn\n```\n\nDo `model = BayesianQDA()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`BayesianQDA(priors=...)`.\n# Hyper-parameters\n\n- `priors = nothing`\n\n- `reg_param = 0.0`\n\n- `store_covariance = false`\n\n- `tol = 0.0001`\n\n"
":name" = "BayesianQDA"
":human_name" = "Bayesian quadratic discriminant analysis"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:priors, :reg_param, :store_covariance, :tol)`"
":hyperparameter_types" = "`(\"Union{Nothing, AbstractVector{T} where T}\", \"Float64\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.BayesianLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.BayesianLDA"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBayesianLDA\n```\n\nModel type for Bayesian linear discriminant analysis, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBayesianLDA = @load BayesianLDA pkg=ScikitLearn\n```\n\nDo `model = BayesianLDA()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`BayesianLDA(solver=...)`.\n# Hyper-parameters\n\n- `solver = svd`\n\n- `shrinkage = nothing`\n\n- `priors = nothing`\n\n- `n_components = nothing`\n\n- `store_covariance = false`\n\n- `tol = 0.0001`\n\n"
":name" = "BayesianLDA"
":human_name" = "Bayesian linear discriminant analysis"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:solver, :shrinkage, :priors, :n_components, :store_covariance, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Union{Nothing, Float64, String}\", \"Union{Nothing, AbstractVector{T} where T}\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SGDClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s874\"} where var\"_s874\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SGDClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSGDClassifier\n```\n\nModel type for sgd classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSGDClassifier = @load SGDClassifier pkg=ScikitLearn\n```\n\nDo `model = SGDClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SGDClassifier(loss=...)`.\n# Hyper-parameters\n\n- `loss = hinge`\n\n- `penalty = l2`\n\n- `alpha = 0.0001`\n\n- `l1_ratio = 0.15`\n\n- `fit_intercept = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.001`\n\n- `shuffle = true`\n\n- `verbose = 0`\n\n- `epsilon = 0.1`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `learning_rate = optimal`\n\n- `eta0 = 0.0`\n\n- `power_t = 0.5`\n\n- `early_stopping = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = 5`\n\n- `class_weight = nothing`\n\n- `warm_start = false`\n\n- `average = false`\n\n"
":name" = "SGDClassifier"
":human_name" = "sgd classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:loss, :penalty, :alpha, :l1_ratio, :fit_intercept, :max_iter, :tol, :shuffle, :verbose, :epsilon, :n_jobs, :random_state, :learning_rate, :eta0, :power_t, :early_stopping, :validation_fraction, :n_iter_no_change, :class_weight, :warm_start, :average)`"
":hyperparameter_types" = "`(\"String\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Int64\", \"Union{Nothing, Float64}\", \"Bool\", \"Int64\", \"Float64\", \"Union{Nothing, Int64}\", \"Any\", \"String\", \"Float64\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Any\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.TheilSenRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.TheilSenRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nTheilSenRegressor\n```\n\nModel type for Theil-Sen regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nTheilSenRegressor = @load TheilSenRegressor pkg=ScikitLearn\n```\n\nDo `model = TheilSenRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`TheilSenRegressor(fit_intercept=...)`.\n# Hyper-parameters\n\n- `fit_intercept = true`\n\n- `copy_X = true`\n\n- `max_subpopulation = 10000`\n\n- `n_subsamples = nothing`\n\n- `max_iter = 300`\n\n- `tol = 0.001`\n\n- `random_state = nothing`\n\n- `n_jobs = nothing`\n\n- `verbose = false`\n\n"
":name" = "TheilSenRegressor"
":human_name" = "Theil-Sen regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:fit_intercept, :copy_X, :max_subpopulation, :n_subsamples, :max_iter, :tol, :random_state, :n_jobs, :verbose)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Int64\", \"Union{Nothing, Int64}\", \"Int64\", \"Float64\", \"Any\", \"Union{Nothing, Int64}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SpectralClustering]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SpectralClustering"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSpectralClustering\n```\n\nModel type for spectral clustering, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSpectralClustering = @load SpectralClustering pkg=ScikitLearn\n```\n\nDo `model = SpectralClustering()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `SpectralClustering(n_clusters=...)`.\n\nApply clustering to a projection of the normalized Laplacian.  In practice spectral clustering is very useful when the structure of the individual clusters is highly non-convex or more generally when a measure of the center and spread of the cluster is not a suitable description of the complete cluster. For instance when clusters are nested circles on the 2D plane.\n"
":name" = "SpectralClustering"
":human_name" = "spectral clustering"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params"]
":hyperparameters" = "`(:n_clusters, :eigen_solver, :random_state, :n_init, :gamma, :affinity, :n_neighbors, :eigen_tol, :assign_labels, :n_jobs)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, String}\", \"Any\", \"Int64\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"String\", \"Union{Nothing, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.Birch]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Multiclass}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.Birch"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nBirch\n```\n\nModel type for birch, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nBirch = @load Birch pkg=ScikitLearn\n```\n\nDo `model = Birch()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `Birch(threshold=...)`.\n\nMemory-efficient, online-learning algorithm provided as an alternative to MiniBatchKMeans. Note: noisy samples are given the label -1.\n"
":name" = "Birch"
":human_name" = "birch"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:threshold, :branching_factor, :n_clusters, :compute_labels, :copy)`"
":hyperparameter_types" = "`(\"Float64\", \"Int64\", \"Int64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.AgglomerativeClustering]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.AgglomerativeClustering"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAgglomerativeClustering\n```\n\nModel type for agglomerative clustering, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nAgglomerativeClustering = @load AgglomerativeClustering pkg=ScikitLearn\n```\n\nDo `model = AgglomerativeClustering()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `AgglomerativeClustering(n_clusters=...)`.\n\nRecursively merges the pair of clusters that minimally increases a given linkage distance. Note: there is no `predict` or `transform`. Instead, inspect the `fitted_params`.\n"
":name" = "AgglomerativeClustering"
":human_name" = "agglomerative clustering"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params"]
":hyperparameters" = "`(:n_clusters, :affinity, :memory, :connectivity, :compute_full_tree, :linkage, :distance_threshold)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Any\", \"Any\", \"Union{Bool, String}\", \"String\", \"Union{Nothing, Float64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ElasticNetRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nElasticNetRegressor\n```\n\nModel type for elastic net regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nElasticNetRegressor = @load ElasticNetRegressor pkg=ScikitLearn\n```\n\nDo `model = ElasticNetRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`ElasticNetRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `l1_ratio = 0.5`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `precompute = false`\n\n- `max_iter = 1000`\n\n- `copy_X = true`\n\n- `tol = 0.0001`\n\n- `warm_start = false`\n\n- `positive = false`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "ElasticNetRegressor"
":human_name" = "elastic net regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :l1_ratio, :fit_intercept, :normalize, :precompute, :max_iter, :copy_X, :tol, :warm_start, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Bool\", \"Bool\", \"Union{Bool, AbstractMatrix{T} where T}\", \"Int64\", \"Bool\", \"Float64\", \"Bool\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.RandomForestClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRandomForestClassifier\n```\n\nModel type for random forest classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRandomForestClassifier = @load RandomForestClassifier pkg=ScikitLearn\n```\n\nDo `model = RandomForestClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`RandomForestClassifier(n_estimators=...)`.\n# Hyper-parameters\n\n- `n_estimators = 100`\n\n- `criterion = gini`\n\n- `max_depth = nothing`\n\n- `min_samples_split = 2`\n\n- `min_samples_leaf = 1`\n\n- `min_weight_fraction_leaf = 0.0`\n\n- `max_features = auto`\n\n- `max_leaf_nodes = nothing`\n\n- `min_impurity_decrease = 0.0`\n\n- `bootstrap = true`\n\n- `oob_score = false`\n\n- `n_jobs = nothing`\n\n- `random_state = nothing`\n\n- `verbose = 0`\n\n- `warm_start = false`\n\n- `class_weight = nothing`\n\n- `ccp_alpha = 0.0`\n\n- `max_samples = nothing`\n\n"
":name" = "RandomForestClassifier"
":human_name" = "random forest classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start, :class_weight, :ccp_alpha, :max_samples)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\", \"Any\", \"Float64\", \"Union{Nothing, Float64, Int64}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LogisticCVClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s558\"} where var\"_s558\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LogisticCVClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLogisticCVClassifier\n```\n\nModel type for logistic regression classifier with built-in cross-validation, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLogisticCVClassifier = @load LogisticCVClassifier pkg=ScikitLearn\n```\n\nDo `model = LogisticCVClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LogisticCVClassifier(Cs=...)`.\n# Hyper-parameters\n\n- `Cs = 10`\n\n- `fit_intercept = true`\n\n- `cv = 5`\n\n- `dual = false`\n\n- `penalty = l2`\n\n- `scoring = nothing`\n\n- `solver = lbfgs`\n\n- `tol = 0.0001`\n\n- `max_iter = 100`\n\n- `class_weight = nothing`\n\n- `n_jobs = nothing`\n\n- `verbose = 0`\n\n- `refit = true`\n\n- `intercept_scaling = 1.0`\n\n- `multi_class = auto`\n\n- `random_state = nothing`\n\n- `l1_ratios = nothing`\n\n"
":name" = "LogisticCVClassifier"
":human_name" = "logistic regression classifier with built-in cross-validation"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:Cs, :fit_intercept, :cv, :dual, :penalty, :scoring, :solver, :tol, :max_iter, :class_weight, :n_jobs, :verbose, :refit, :intercept_scaling, :multi_class, :random_state, :l1_ratios)`"
":hyperparameter_types" = "`(\"Union{Int64, AbstractVector{Float64}}\", \"Bool\", \"Any\", \"Bool\", \"String\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Any\", \"Union{Nothing, Int64}\", \"Int64\", \"Bool\", \"Float64\", \"String\", \"Any\", \"Union{Nothing, AbstractVector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultiTaskElasticNetRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultiTaskElasticNetRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultiTaskElasticNetRegressor\n```\n\nModel type for multi-target elastic net regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultiTaskElasticNetRegressor = @load MultiTaskElasticNetRegressor pkg=ScikitLearn\n```\n\nDo `model = MultiTaskElasticNetRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MultiTaskElasticNetRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `l1_ratio = 0.5`\n\n- `fit_intercept = true`\n\n- `normalize = true`\n\n- `copy_X = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `warm_start = false`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "MultiTaskElasticNetRegressor"
":human_name" = "multi-target elastic net regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :l1_ratio, :fit_intercept, :normalize, :copy_X, :max_iter, :tol, :warm_start, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Float64, Vector{Float64}}\", \"Bool\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.ExtraTreesRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.ExtraTreesRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nExtraTreesRegressor\n```\n\nModel type for extra trees regressor, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nExtraTreesRegressor = @load ExtraTreesRegressor pkg=ScikitLearn\n```\n\nDo `model = ExtraTreesRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `ExtraTreesRegressor(n_estimators=...)`.\n\nExtra trees regressor, fits a number of randomized decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.\n"
":name" = "ExtraTreesRegressor"
":human_name" = "extra trees regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_estimators, :criterion, :max_depth, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_features, :max_leaf_nodes, :min_impurity_decrease, :bootstrap, :oob_score, :n_jobs, :random_state, :verbose, :warm_start)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Union{Nothing, Int64}\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Union{Nothing, Float64, Int64, String}\", \"Union{Nothing, Int64}\", \"Float64\", \"Bool\", \"Bool\", \"Union{Nothing, Int64}\", \"Any\", \"Int64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.LassoRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.LassoRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLassoRegressor\n```\n\nModel type for lasso regressor, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nLassoRegressor = @load LassoRegressor pkg=ScikitLearn\n```\n\nDo `model = LassoRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`LassoRegressor(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1.0`\n\n- `fit_intercept = true`\n\n- `normalize = false`\n\n- `precompute = false`\n\n- `copy_X = true`\n\n- `max_iter = 1000`\n\n- `tol = 0.0001`\n\n- `warm_start = false`\n\n- `positive = false`\n\n- `random_state = nothing`\n\n- `selection = cyclic`\n\n"
":name" = "LassoRegressor"
":human_name" = "lasso regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_intercept, :normalize, :precompute, :copy_X, :max_iter, :tol, :warm_start, :positive, :random_state, :selection)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Bool\", \"Union{Bool, AbstractMatrix{T} where T}\", \"Bool\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Any\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.MultinomialNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.MultinomialNBClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultinomialNBClassifier\n```\n\nModel type for multinomial naive Bayes classifier, based on [ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultinomialNBClassifier = @load MultinomialNBClassifier pkg=ScikitLearn\n```\n\nDo `model = MultinomialNBClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `MultinomialNBClassifier(alpha=...)`.\n\nMultinomial naive bayes classifier. It is suitable for classification with discrete features (e.g. word counts for text classification).\n"
":name" = "MultinomialNBClassifier"
":human_name" = "multinomial naive Bayes classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha, :fit_prior, :class_prior)`"
":hyperparameter_types" = "`(\"Float64\", \"Bool\", \"Union{Nothing, AbstractVector{T} where T}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.GradientBoostingRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.GradientBoostingRegressor"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGradientBoostingRegressor\n```\n\nModel type for gradient boosting ensemble regression, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGradientBoostingRegressor = @load GradientBoostingRegressor pkg=ScikitLearn\n```\n\nDo `model = GradientBoostingRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`GradientBoostingRegressor(loss=...)`.\n# Hyper-parameters\n\n- `loss = ls`\n\n- `learning_rate = 0.1`\n\n- `n_estimators = 100`\n\n- `subsample = 1.0`\n\n- `criterion = friedman_mse`\n\n- `min_samples_split = 2`\n\n- `min_samples_leaf = 1`\n\n- `min_weight_fraction_leaf = 0.0`\n\n- `max_depth = 3`\n\n- `min_impurity_decrease = 0.0`\n\n- `init = nothing`\n\n- `random_state = nothing`\n\n- `max_features = nothing`\n\n- `alpha = 0.9`\n\n- `verbose = 0`\n\n- `max_leaf_nodes = nothing`\n\n- `warm_start = false`\n\n- `validation_fraction = 0.1`\n\n- `n_iter_no_change = nothing`\n\n- `tol = 0.0001`\n\n"
":name" = "GradientBoostingRegressor"
":human_name" = "gradient boosting ensemble regression"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:loss, :learning_rate, :n_estimators, :subsample, :criterion, :min_samples_split, :min_samples_leaf, :min_weight_fraction_leaf, :max_depth, :min_impurity_decrease, :init, :random_state, :max_features, :alpha, :verbose, :max_leaf_nodes, :warm_start, :validation_fraction, :n_iter_no_change, :tol)`"
":hyperparameter_types" = "`(\"String\", \"Float64\", \"Int64\", \"Float64\", \"String\", \"Union{Float64, Int64}\", \"Union{Float64, Int64}\", \"Float64\", \"Int64\", \"Float64\", \"Any\", \"Any\", \"Union{Nothing, Float64, Int64, String}\", \"Float64\", \"Int64\", \"Union{Nothing, Int64}\", \"Bool\", \"Float64\", \"Union{Nothing, Int64}\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ScikitLearn.SVMClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s1162\"} where var\"_s1162\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "ScikitLearn"
":package_license" = "BSD"
":load_path" = "MLJScikitLearnInterface.SVMClassifier"
":package_uuid" = "3646fa90-6ef7-5e7e-9f22-8aca16db6324"
":package_url" = "https://github.com/cstjean/ScikitLearn.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVMClassifier\n```\n\nModel type for C-support vector classifier, based on\n[ScikitLearn.jl](https://github.com/cstjean/ScikitLearn.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nSVMClassifier = @load SVMClassifier pkg=ScikitLearn\n```\n\nDo `model = SVMClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`SVMClassifier(C=...)`.\n# Hyper-parameters\n\n- `C = 1.0`\n\n- `kernel = rbf`\n\n- `degree = 3`\n\n- `gamma = auto`\n\n- `coef0 = 0.0`\n\n- `shrinking = true`\n\n- `tol = 0.001`\n\n- `cache_size = 200`\n\n- `max_iter = -1`\n\n- `decision_function_shape = ovr`\n\n- `random_state = nothing`\n\n"
":name" = "SVMClassifier"
":human_name" = "C-support vector classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:C, :kernel, :degree, :gamma, :coef0, :shrinking, :tol, :cache_size, :max_iter, :decision_function_shape, :random_state)`"
":hyperparameter_types" = "`(\"Float64\", \"Union{Function, String}\", \"Int64\", \"Union{Float64, String}\", \"Float64\", \"Bool\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[ParallelKMeans.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractArray{var\"_s207\", N} where {var\"_s207\"<:ScientificTypesBase.Multiclass, N}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "ParallelKMeans"
":package_license" = "MIT"
":load_path" = "ParallelKMeans.KMeans"
":package_uuid" = "42b8e9d4-006b-409a-8472-7f34b3fb58af"
":package_url" = "https://github.com/PyDataBlog/ParallelKMeans.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Parallel & lightning fast implementation of all available variants of the KMeans clustering algorithm\n                             in native Julia. Compatible with Julia 1.3+"
":name" = "KMeans"
":human_name" = "k means"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:algo, :k_init, :k, :tol, :max_iters, :copy, :threads, :rng, :weights, :init)`"
":hyperparameter_types" = "`(\"Union{Symbol, ParallelKMeans.AbstractKMeansAlg}\", \"String\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Int64\", \"Union{Int64, Random.AbstractRNG}\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NaiveBayes.GaussianNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s2\"} where var\"_s2\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NaiveBayes"
":package_license" = "unknown"
":load_path" = "MLJNaiveBayesInterface.GaussianNBClassifier"
":package_uuid" = "9bbee03b-0db5-5f46-924f-b5c9c21b8c60"
":package_url" = "https://github.com/dfdx/NaiveBayes.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nGaussianNBClassifier\n```\n\nModel type for gaussian nb classifier, based on\n[NaiveBayes.jl](https://github.com/dfdx/NaiveBayes.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nGaussianNBClassifier = @load GaussianNBClassifier pkg=NaiveBayes\n```\n\nDo `model = GaussianNBClassifier()` to construct an instance with default hyper-parameters. "
":name" = "GaussianNBClassifier"
":human_name" = "gaussian nb classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[NaiveBayes.MultinomialNBClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s2\"} where var\"_s2\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "NaiveBayes"
":package_license" = "unknown"
":load_path" = "MLJNaiveBayesInterface.MultinomialNBClassifier"
":package_uuid" = "9bbee03b-0db5-5f46-924f-b5c9c21b8c60"
":package_url" = "https://github.com/dfdx/NaiveBayes.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMultinomialNBClassifier\n```\n\nModel type for multinomial nb classifier, based on\n[NaiveBayes.jl](https://github.com/dfdx/NaiveBayes.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nMultinomialNBClassifier = @load MultinomialNBClassifier pkg=NaiveBayes\n```\n\nDo `model = MultinomialNBClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`MultinomialNBClassifier(alpha=...)`.\n# Hyper-parameters\n\n- `alpha = 1`\n\n"
":name" = "MultinomialNBClassifier"
":human_name" = "multinomial nb classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:alpha,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.LDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.LDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Multiclass linear discriminant analysis. The algorithm learns a\nprojection matrix `P` that projects a feature matrix `Xtrain` onto a lower dimensional\nspace of dimension `out_dim` such that the trace of the transformed between-class \nscatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the transformed \nwithin-class scatter matrix (`Pᵀ*Sw*P`).The projection matrix is scaled such that \n`Pᵀ*Sw*P=I` or `Pᵀ*Σw*P=I`(where `Σw` is the within-class covariance matrix) .\nPredicted class posterior probability for feature matrix `Xtest` are derived by \napplying a softmax transformationto a matrix `Pr`, such that  rowᵢ of `Pr` contains \ncomputed distances(based on a distance metric) in the transformed space of rowᵢ in \n`Xtest` to the centroid of each class.\n"
":name" = "LDA"
":human_name" = "lda"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:method, :cov_w, :cov_b, :out_dim, :regcoef, :dist)`"
":hyperparameter_types" = "`(\"Symbol\", \"StatsBase.CovarianceEstimator\", \"StatsBase.CovarianceEstimator\", \"Int64\", \"Float64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.MultitargetLinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.MultitargetLinearRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multitarget Linear Regression. Learns linear combinations of given\nvariables to fit the responses by minimizing the squared error between.\n"
":name" = "MultitargetLinearRegressor"
":human_name" = "multitarget linear regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:bias,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.BayesianSubspaceLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.BayesianSubspaceLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "   Bayesian Multiclass linear discriminant analysis. Suitable for high dimensional data \n(Avoids computing scatter matrices `Sw` ,`Sb`). The algorithm learns a projection \nmatrix `P = W*L` (`Sw`), that projects a feature matrix `Xtrain` onto a lower \ndimensional space of dimension `nc-1` such that the trace of the transformed \nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the \ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = mult*I` or `Pᵀ*Σw*P=mult/(n-nc)*I` (where `n` is the number of \ntraining samples, `mult` is  one of `n` or `1` depending on whether `Sb` is normalized,\n`Σw` is the within-class covariance matrix, and `nc` is the number of unique classes in\n`y`) and also obeys `Wᵀ*Sb*p = λ*Wᵀ*Sw*p`, for every column `p` in `P`.\nPosterior class probability distibution are derived by applying Bayes rule with a\nmultivariate Gaussian class-conditional distribution\n"
":name" = "BayesianSubspaceLDA"
":human_name" = "bayesian subspace lda"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:normalize, :out_dim, :priors)`"
":hyperparameter_types" = "`(\"Bool\", \"Int64\", \"Union{Nothing, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.FactorAnalysis]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.FactorAnalysis"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Factor Analysis"
":name" = "FactorAnalysis"
":human_name" = "factor analysis"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:method, :maxoutdim, :maxiter, :tol, :eta, :mean)`"
":hyperparameter_types" = "`(\"Symbol\", \"Int64\", \"Int64\", \"Real\", \"Real\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.LinearRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear Regression. Learns a linear combination of given\nvariables to fit the response by minimizing the squared error between.\n"
":name" = "LinearRegressor"
":human_name" = "linear regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:bias,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.ICA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.ICA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Independent component analysis."
":name" = "ICA"
":human_name" = "ica"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:k, :alg, :fun, :do_whiten, :maxiter, :tol, :winit, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Symbol\", \"Bool\", \"Int64\", \"Real\", \"Union{Nothing, Matrix{var\\\"_s62\\\"} where var\\\"_s62\\\"<:Real}\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.PPCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.PPCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Probabilistic principal component analysis"
":name" = "PPCA"
":human_name" = "ppca"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:maxoutdim, :method, :maxiter, :tol, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Int64\", \"Real\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.RidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.RidgeRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Ridge regressor with regularization parameter lambda. Learns a\nlinear regression with a penalty on the l2 norm of the coefficients.\n"
":name" = "RidgeRegressor"
":human_name" = "ridge regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :bias)`"
":hyperparameter_types" = "`(\"Union{Real, AbstractVecOrMat{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.KernelPCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.KernelPCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Kernel principal component analysis."
":name" = "KernelPCA"
":human_name" = "kernel pca"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:maxoutdim, :kernel, :solver, :inverse, :beta, :tol, :maxiter)`"
":hyperparameter_types" = "`(\"Int64\", \"Union{Nothing, Function}\", \"Symbol\", \"Bool\", \"Real\", \"Real\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.MultitargetRidgeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.MultitargetRidgeRegressor"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multitarget Ridge regressor with regularization parameter lambda. Learns a\nMultitarget linear regression with a penalty on the l2 norm of the coefficients.\n"
":name" = "MultitargetRidgeRegressor"
":human_name" = "multitarget ridge regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:lambda, :bias)`"
":hyperparameter_types" = "`(\"Union{Real, AbstractVecOrMat{T} where T}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.SubspaceLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.SubspaceLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multiclass linear discriminant analysis. Suitable for high\ndimensional data (Avoids computing scatter matrices `Sw` ,`Sb`). The algorithm learns a\nprojection matrix `P = W*L` that projects a feature matrix `Xtrain` onto a lower\ndimensional space of dimension `nc - 1` such that the trace of the transformed\nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the\ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = mult*I` or `Pᵀ*Σw*P=mult/(n-nc)*I` (where `n` is the number of \ntraining samples, mult` is  one of `n` or `1` depending on whether `Sb` is normalized, \n`Σw` is the within-class covariance matrix, and `nc` is the number of unique classes \nin `y`) and also obeys `Wᵀ*Sb*p = λ*Wᵀ*Sw*p`, for every column `p` in `P`.\nPredicted class posterior probability for feature matrix `Xtest` are derived by \napplying a softmax transformation to a matrix `Pr`, such that  rowᵢ of `Pr` contains \ncomputed distances(based on a distance metric) in the transformed space of rowᵢ in \n`Xtest` to the centroid of each class.\n"
":name" = "SubspaceLDA"
":human_name" = "subspace lda"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:normalize, :out_dim, :dist)`"
":hyperparameter_types" = "`(\"Bool\", \"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.BayesianLDA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s90\"} where var\"_s90\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.BayesianLDA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Bayesian Multiclass linear discriminant analysis. The algorithm\nlearns a projection matrix `P` that projects a feature matrix `Xtrain` onto a lower\ndimensional space of dimension `out_dim` such that the trace of the transformed\nbetween-class scatter matrix(`Pᵀ*Sb*P`) is maximized relative to the trace of the\ntransformed within-class scatter matrix (`Pᵀ*Sw*P`). The projection matrix is scaled \nsuch that `Pᵀ*Sw*P = n` or `Pᵀ*Σw*P=I` (Where `n` is the number of training samples \nand `Σw` is the within-class covariance matrix).\nPredicted class posterior probability distibution are derived by applying Bayes rule \nwith a multivariate Gaussian class-conditional distribution.\n"
":name" = "BayesianLDA"
":human_name" = "bayesian lda"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:method, :cov_w, :cov_b, :out_dim, :regcoef, :priors)`"
":hyperparameter_types" = "`(\"Symbol\", \"StatsBase.CovarianceEstimator\", \"StatsBase.CovarianceEstimator\", \"Int64\", \"Float64\", \"Union{Nothing, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MultivariateStats.PCA]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "MultivariateStats"
":package_license" = "MIT"
":load_path" = "MLJMultivariateStatsInterface.PCA"
":package_uuid" = "6f286f6a-111f-5878-ab1e-185364afe411"
":package_url" = "https://github.com/JuliaStats/MultivariateStats.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "  Principal component analysis. Learns a linear transformation to\nproject the data  on a lower dimensional space while preserving most of the initial\nvariance.\n"
":name" = "PCA"
":human_name" = "pca"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:maxoutdim, :method, :pratio, :mean)`"
":hyperparameter_types" = "`(\"Int64\", \"Symbol\", \"Float64\", \"Union{Nothing, Real, Vector{Float64}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.AdaBoostStumpClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.AdaBoostStumpClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAdaBoostStumpClassifier\n```\n\nModel type for Ada-boosted stump classifier, based on [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nAdaBoostStumpClassifier = @load AdaBoostStumpClassifier pkg=DecisionTree\n```\n\nDo `model = AdaBoostStumpClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `AdaBoostStumpClassifier(n_iter=...)`.\n\n# Training data\n\nIn MLJ or MLJBase, bind an instance `model` to data with\n\n```\nmach = machine(model, X, y)\n```\n\nwhere:\n\n  * `X`: any table of input features (eg, a `DataFrame`) whose columns each have one of the following element scitypes: `Continuous`, `Count`, or `<:OrderedFactor`.\n  * `y`: the target, which can be any `AbstractVector` whose element scitype is `<:OrderedFactor` or `<:Multiclass`.\n\nTrain the machine with `fit!(mach, rows=...)`.\n\n# Hyper-parameters\n\n  * `n_iter=10`:   number of iterations of AdaBoost\n\n# Operations\n\n  * `predict(mach, Xnew)`: return predictions of the target given features `Xnew` having the same scitype as `X` above. Predictions are probabilistic, but uncalibrated.\n  * `predict_mode(mach, Xnew)`: instead return the mode of each prediction above.\n\n# Fitted Parameters\n\nThe fields of `fitted_params(mach)` are:\n\n  * `stumps`: the `Ensemble` object returned by the core DecisionTree.jl algorithm.\n  * `coefficients`: the stump coefficients (one per stump)\n\n```\nusing MLJ\nBooster = @load AdaBoostStumpClassifier pkg=DecisionTree\nbooster = Booster(n_iter=15)\n\nX, y = @load_iris\nmach = machine(booster, X, y) |> fit!\n\nXnew = (sepal_length = [6.4, 7.2, 7.4],\n        sepal_width = [2.8, 3.0, 2.8],\n        petal_length = [5.6, 5.8, 6.1],\n        petal_width = [2.1, 1.6, 1.9],)\nyhat = predict(mach, Xnew) # probabilistic predictions\npredict_mode(mach, Xnew)   # point predictions\npdf.(yhat, \"virginica\")    # probabilities for the \"verginica\" class\n\nfitted_params(mach).stumps # raw `Ensemble` object from DecisionTree.jl\nfitted_params(mach).coefs  # coefficient associated with each stump\n```\n\nSee also [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl) and the unwrapped model type [`MLJDecisionTreeInterface.DecisionTree.AdaBoostStumpClassifier`](@ref).\n"
":name" = "AdaBoostStumpClassifier"
":human_name" = "Ada-boosted stump classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:n_iter,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.DecisionTreeRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.DecisionTreeRegressor"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDecisionTreeRegressor\n```\n\nModel type for CART decision tree regressor, based on [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nDecisionTreeRegressor = @load DecisionTreeRegressor pkg=DecisionTree\n```\n\nDo `model = DecisionTreeRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `DecisionTreeRegressor(max_depth=...)`.\n\n# Training data\n\nIn MLJ or MLJBase, bind an instance `model` to data with\n\n```\nmach = machine(model, X, y)\n```\n\nwhere\n\n  * `X`: any table of input features (eg, a `DataFrame`) whose columns each have one of the following element scitypes: `Continuous`, `Count`, or `<:OrderedFactor`.\n  * `y`: the target, which can be any `AbstractVector` whose element scitype is `Continuous`.\n\nTrain the machine with `fit!(mach, rows=...)`.\n\n# Hyper-parameters\n\n  * `max_depth=-1`:          max depth of the decision tree (-1=any)\n  * `min_samples_leaf=1`:    max number of samples each leaf needs to have\n  * `min_samples_split=2`:   min number of samples needed for a split\n  * `min_purity_increase=0`: min purity needed for a split\n  * `n_subfeatures=0`: number of features to select at random (0 for all, -1 for square root of number of features)\n  * `post_prune=false`:      set to `true` for post-fit pruning\n  * `merge_purity_threshold=1.0`: (post-pruning) merge leaves having                          combined purity `>= merge_purity_threshold`\n  * `rng=Random.GLOBAL_RNG`: random number generator or seed\n\n# Operations\n\n  * `predict(mach, Xnew)`: return predictions of the target given new features `Xnew` having the same scitype as `X` above.\n\n# Fitted parameters\n\nThe fields of `fitted_params(mach)` are:\n\n  * `tree`: the tree or stump object returned by the core DecisionTree.jl algorithm\n\n# Examples\n\n```\nusing MLJ\nTree = @load DecisionTreeRegressor pkg=DecisionTree\ntree = Tree(max_depth=4, min_samples_split=3)\n\nX, y = make_regression(100, 2) # synthetic data\nmach = machine(tree, X, y) |> fit!\n\nXnew, _ = make_regression(3, 2)\nyhat = predict(mach, Xnew) # new predictions\n\nfitted_params(mach).tree # raw tree or stump object from DecisionTree.jl\n```\n\nSee also [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl) and the unwrapped model type [`MLJDecisionTreeInterface.DecisionTree.DecisionTreeRegressor`](@ref).\n"
":name" = "DecisionTreeRegressor"
":human_name" = "CART decision tree regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :post_prune, :merge_purity_threshold, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.DecisionTreeClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.DecisionTreeClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDecisionTreeClassifier\n```\n\nModel type for CART decision tree classifier, based on [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nDecisionTreeClassifier = @load DecisionTreeClassifier pkg=DecisionTree\n```\n\nDo `model = DecisionTreeClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `DecisionTreeClassifier(max_depth=...)`.\n\n# Training data\n\nIn MLJ or MLJBase, bind an instance `model` to data with\n\n```\nmach = machine(model, X, y)\n```\n\nwhere\n\n  * `X`: any table of input features (eg, a `DataFrame`) whose columns each have one of the following element scitypes: `Continuous`, `Count`, or `<:OrderedFactor`.\n  * `y`: is the target, which can be any `AbstractVector` whose element scitype is `<:OrderedFactor` or `<:Multiclass`.\n\nTrain the machine using `fit!(mach, rows=...)`.\n\n# Hyper-parameters\n\n  * `max_depth=-1`:          max depth of the decision tree (-1=any)\n  * `min_samples_leaf=1`:    max number of samples each leaf needs to have\n  * `min_samples_split=2`:   min number of samples needed for a split\n  * `min_purity_increase=0`: min purity needed for a split\n  * `n_subfeatures=0`: number of features to select at random (0 for all, -1 for square root of number of features)\n  * `post_prune=false`:      set to `true` for post-fit pruning\n  * `merge_purity_threshold=1.0`: (post-pruning) merge leaves having                          combined purity `>= merge_purity_threshold`\n  * `display_depth=5`:       max depth to show when displaying the tree\n  * `rng=Random.GLOBAL_RNG`: random number generator or seed\n\n# Operations\n\n  * `predict(mach, Xnew)`: return predictions of the target given features `Xnew` having the same scitype as `X` above. Predictions are probabilistic, but uncalibrated.\n  * `predict_mode(mach, Xnew)`: instead return the mode of each prediction above.\n\n# Fitted parameters\n\nThe fields of `fitted_params(mach)` are:\n\n  * `tree`: the tree or stump object returned by the core DecisionTree.jl algorithm\n  * `encoding`: dictionary of target classes keyed on integers used internally by DecisionTree.jl; needed to interpret pretty printing of tree (obtained by calling `fit!(mach, verbosity=2)` or from report - see below)\n  * `features`: the names of the features encountered in training, in an order consistent with the output of `print_tree` (see below)\n\n# Report\n\nThe fields of `report(mach)` are:\n\n  * `classes_seen`: list of target classes actually observed in training\n  * `print_tree`: method to print a pretty representation of the fitted tree, with single argument the tree depth; interpretation requires internal integer-class encoding (see \"Fitted parameters\" above).\n  * `features`: the names of the features encountered in training, in an order consistent with the output of `print_tree` (see below)\n\n# Examples\n\n```\nusing MLJ\nTree = @load DecisionTreeClassifier pkg=DecisionTree\ntree = Tree(max_depth=4, min_samples_split=3)\n\nX, y = @load_iris\nmach = machine(tree, X, y) |> fit!\n\nXnew = (sepal_length = [6.4, 7.2, 7.4],\n        sepal_width = [2.8, 3.0, 2.8],\n        petal_length = [5.6, 5.8, 6.1],\n        petal_width = [2.1, 1.6, 1.9],)\nyhat = predict(mach, Xnew) # probabilistic predictions\npredict_mode(mach, Xnew)   # point predictions\npdf.(yhat, \"virginica\")    # probabilities for the \"verginica\" class\n\nfitted_params(mach).tree # raw tree or stump object from DecisionTrees.jl\n\njulia> report(mach).print_tree(3)\nFeature 4, Threshold 0.8\nL-> 1 : 50/50\nR-> Feature 4, Threshold 1.75\n    L-> Feature 3, Threshold 4.95\n        L->\n        R->\n    R-> Feature 3, Threshold 4.85\n        L->\n        R-> 3 : 43/43\n```\n\nTo interpret the internal class labelling:\n\n```\njulia> fitted_params(mach).encoding\nDict{CategoricalArrays.CategoricalValue{String, UInt32}, UInt32} with 3 entries:\n  \"virginica\"  => 0x00000003\n  \"setosa\"     => 0x00000001\n  \"versicolor\" => 0x00000002\n```\n\nSee also [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl) and the unwrapped model type [`MLJDecisionTreeInterface.DecisionTree.DecisionTreeClassifier`](@ref).\n"
":name" = "DecisionTreeClassifier"
":human_name" = "CART decision tree classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :post_prune, :merge_purity_threshold, :display_depth, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Bool\", \"Float64\", \"Int64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.RandomForestRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.RandomForestRegressor"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRandomForestRegressor\n```\n\nModel type for CART random forest regressor, based on [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRandomForestRegressor = @load RandomForestRegressor pkg=DecisionTree\n```\n\nDo `model = RandomForestRegressor()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `RandomForestRegressor(max_depth=...)`.\n\n# Training data\n\nIn MLJ or MLJBase, bind an instance `model` to data with\n\n```\nmach = machine(model, X, y)\n```\n\nwhere\n\n  * `X`: any table of input features (eg, a `DataFrame`) whose columns each have one of the following element scitypes: `Continuous`, `Count`, or `<:OrderedFactor`.\n  * `y`: the target, which can be any `AbstractVector` whose element scitype is `Continuous`.\n\nTrain the machine with `fit!(mach, rows=...)`.\n\n# Hyper-parameters\n\n  * `max_depth=-1`:          max depth of the decision tree (-1=any)\n  * `min_samples_leaf=1`:    min number of samples each leaf needs to have\n  * `min_samples_split=2`:   min number of samples needed for a split\n  * `min_purity_increase=0`: min purity needed for a split\n  * `n_subfeatures=-1`: number of features to select at random (0 for all, -1 for square root of number of features)\n  * `n_trees=10`:            number of trees to train\n  * `sampling_fraction=0.7`  fraction of samples to train each tree on\n  * `rng=Random.GLOBAL_RNG`: random number generator or seed\n\n# Operations\n\n  * `predict(mach, Xnew)`: return predictions of the target given new features `Xnew` having the same scitype as `X` above.\n\n# Fitted parameters\n\nThe fields of `fitted_params(mach)` are:\n\n  * `forest`: the `Ensemble` object returned by the core DecisionTree.jl algorithm\n\n# Examples\n\n```\nusing MLJ\nForest = @load RandomForestRegressor pkg=DecisionTree\nforest = Forest(max_depth=4, min_samples_split=3)\n\nX, y = make_regression(100, 2) # synthetic data\nmach = machine(forest, X, y) |> fit!\n\nXnew, _ = make_regression(3, 2)\nyhat = predict(mach, Xnew) # new predictions\n\nfitted_params(mach).forest # raw `Ensemble` object from DecisionTree.jl\n```\n\nSee also [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl) and the unwrapped model type [`MLJDecisionTreeInterface.DecisionTree.RandomForestRegressor`](@ref).\n"
":name" = "RandomForestRegressor"
":human_name" = "CART random forest regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :n_trees, :sampling_fraction, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[DecisionTree.RandomForestClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:Union{AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Count, AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.OrderedFactor}, AbstractVector{var\"_s39\"} where var\"_s39\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "DecisionTree"
":package_license" = "MIT"
":load_path" = "MLJDecisionTreeInterface.RandomForestClassifier"
":package_uuid" = "7806a523-6efd-50cb-b5f6-3fa6f1930dbb"
":package_url" = "https://github.com/bensadeghi/DecisionTree.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRandomForestClassifier\n```\n\nModel type for CART random forest classifier, based on [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl), and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\n```\nRandomForestClassifier = @load RandomForestClassifier pkg=DecisionTree\n```\n\nDo `model = RandomForestClassifier()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in `RandomForestClassifier(max_depth=...)`.\n\n# Training data\n\nIn MLJ or MLJBase, bind an instance `model` to data with\n\n```\nmach = machine(model, X, y)\n```\n\nwhere\n\n  * `X`: any table of input features (eg, a `DataFrame`) whose columns each have one of the following element scitypes: `Continuous`, `Count`, or `<:OrderedFactor`.\n  * `y`: the target, which can be any `AbstractVector` whose element scitype is `<:OrderedFactor` or `<:Multiclass`.\n\nTrain the machine with `fit!(mach, rows=...)`.\n\n# Hyper-parameters\n\n  * `max_depth=-1`:          max depth of the decision tree (-1=any)\n  * `min_samples_leaf=1`:    min number of samples each leaf needs to have\n  * `min_samples_split=2`:   min number of samples needed for a split\n  * `min_purity_increase=0`: min purity needed for a split\n  * `n_subfeatures=-1`: number of features to select at random (0 for all, -1 for square root of number of features)\n  * `n_trees=10`:            number of trees to train\n  * `sampling_fraction=0.7`  fraction of samples to train each tree on\n  * `rng=Random.GLOBAL_RNG`: random number generator or seed\n\n# Operations\n\n  * `predict(mach, Xnew)`: return predictions of the target given features `Xnew` having the same scitype as `X` above. Predictions are probabilistic, but uncalibrated.\n  * `predict_mode(mach, Xnew)`: instead return the mode of each prediction above.\n\n# Fitted parameters\n\nThe fields of `fitted_params(mach)` are:\n\n  * `forest`: the `Ensemble` object returned by the core DecisionTree.jl algorithm\n\n# Examples\n\n```\nusing MLJ\nForest = @load RandomForestClassifier pkg=DecisionTree\nforest = Forest(min_samples_split=6, n_subfeatures=3)\n\nX, y = @load_iris\nmach = machine(forest, X, y) |> fit!\n\nXnew = (sepal_length = [6.4, 7.2, 7.4],\n        sepal_width = [2.8, 3.0, 2.8],\n        petal_length = [5.6, 5.8, 6.1],\n        petal_width = [2.1, 1.6, 1.9],)\nyhat = predict(mach, Xnew) # probabilistic predictions\npredict_mode(mach, Xnew)   # point predictions\npdf.(yhat, \"virginica\")    # probabilities for the \"verginica\" class\n\nfitted_params(mach).forest # raw `Ensemble` object from DecisionTrees.jl\n```\n\nSee also [DecisionTree.jl](https://github.com/bensadeghi/DecisionTree.jl) and the unwrapped model type [`MLJDecisionTreeInterface.DecisionTree.RandomForestClassifier`](@ref).\n"
":name" = "RandomForestClassifier"
":human_name" = "CART random forest classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`(:max_depth, :min_samples_leaf, :min_samples_split, :min_purity_increase, :n_subfeatures, :n_trees, :sampling_fraction, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[Clustering.KMeans]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "Clustering"
":package_license" = "MIT"
":load_path" = "MLJClusteringInterface.KMeans"
":package_uuid" = "aaaa29a8-35af-508c-8bc3-b662a17a0fe5"
":package_url" = "https://github.com/JuliaStats/Clustering.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Means algorithm: find K centroids corresponding to K clusters in the data.   \n"
":name" = "KMeans"
":human_name" = "k means"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:k, :metric)`"
":hyperparameter_types" = "`(\"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[Clustering.KMedoids]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`true`"
":package_name" = "Clustering"
":package_license" = "MIT"
":load_path" = "MLJClusteringInterface.KMedoids"
":package_uuid" = "aaaa29a8-35af-508c-8bc3-b662a17a0fe5"
":package_url" = "https://github.com/JuliaStats/Clustering.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "K-Medoids algorithm: find K centroids corresponding to K clusters in the data.\nUnlike K-Means, the centroids are found among data points themselves.\n"
":name" = "KMedoids"
":human_name" = "k medoids"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":transform"]
":hyperparameters" = "`(:k, :metric)`"
":hyperparameter_types" = "`(\"Int64\", \"Distances.SemiMetric\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJText.TfidfTransformer]
":input_scitype" = "`Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":output_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJText"
":package_license" = "MIT"
":load_path" = "MLJText.TfidfTransformer"
":package_uuid" = "7876af07-990d-54b4-ab0e-23690620f79a"
":package_url" = "https://github.com/JuliaAI/MLJText.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Build TF-IDF matrix from raw documents"
":name" = "TfidfTransformer"
":human_name" = "tfidf transformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params"]
":hyperparameters" = "`(:max_doc_freq, :min_doc_freq, :smooth_idf)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJText.CountTransformer]
":input_scitype" = "`Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":output_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`Union{AbstractVector{var\"_s34\"} where var\"_s34\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s33\"} where var\"_s33\"<:(ScientificTypesBase.Multiset{var\"_s4\"} where var\"_s4\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJText"
":package_license" = "MIT"
":load_path" = "MLJText.CountTransformer"
":package_uuid" = "7876af07-990d-54b4-ab0e-23690620f79a"
":package_url" = "https://github.com/JuliaAI/MLJText.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Build Bag-of-Words matrix from word counts for corpus of documents"
":name" = "CountTransformer"
":human_name" = "count transformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params"]
":hyperparameters" = "`(:max_doc_freq, :min_doc_freq)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJText.BM25Transformer]
":input_scitype" = "`Union{AbstractVector{var\"_s91\"} where var\"_s91\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s90\"} where var\"_s90\"<:(ScientificTypesBase.Multiset{var\"_s34\"} where var\"_s34\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s33\"} where var\"_s33\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":output_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{AbstractVector{var\"_s91\"} where var\"_s91\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s90\"} where var\"_s90\"<:(ScientificTypesBase.Multiset{var\"_s34\"} where var\"_s34\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s33\"} where var\"_s33\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractMatrix{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`Union{AbstractVector{var\"_s91\"} where var\"_s91\"<:AbstractVector{ScientificTypesBase.Textual}, AbstractVector{var\"_s90\"} where var\"_s90\"<:(ScientificTypesBase.Multiset{var\"_s34\"} where var\"_s34\"<:(Tuple{Vararg{ScientificTypesBase.Textual, var\"_s1\"}} where var\"_s1\")), AbstractVector{var\"_s33\"} where var\"_s33\"<:ScientificTypesBase.Multiset{ScientificTypesBase.Textual}}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJText"
":package_license" = "MIT"
":load_path" = "MLJText.BM25Transformer"
":package_uuid" = "7876af07-990d-54b4-ab0e-23690620f79a"
":package_url" = "https://github.com/JuliaAI/MLJText.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Build BM-25 matrix from raw documents"
":name" = "BM25Transformer"
":human_name" = "b m25 transformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fitted_params"]
":hyperparameters" = "`(:max_doc_freq, :min_doc_freq, :κ, :β, :smooth_idf)`"
":hyperparameter_types" = "`(\"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostCount]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Count}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostCount"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Count` univariate targets, using a Poisson objective function. "
":name" = "XGBoostCount"
":human_name" = "xg boost count"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostRegressor"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Continuous` univariate targets. "
":name" = "XGBoostRegressor"
":human_name" = "xg boost regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[XGBoost.XGBoostClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "XGBoost"
":package_license" = "unknown"
":load_path" = "MLJXGBoostInterface.XGBoostClassifier"
":package_uuid" = "009559a3-9522-5dbb-924b-0b6ed2b22bb9"
":package_url" = "https://github.com/dmlc/XGBoost.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "The XGBoost gradient boosting method, for use with `Finite` univariate targets (`Multiclass`, `OrderedFactor` and `Binary=Finite{2}`)."
":name" = "XGBoostClassifier"
":human_name" = "xg boost classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:num_round, :booster, :disable_default_eval_metric, :eta, :gamma, :max_depth, :min_child_weight, :max_delta_step, :subsample, :colsample_bytree, :colsample_bylevel, :lambda, :alpha, :tree_method, :sketch_eps, :scale_pos_weight, :updater, :refresh_leaf, :process_type, :grow_policy, :max_leaves, :max_bin, :predictor, :sample_type, :normalize_type, :rate_drop, :one_drop, :skip_drop, :feature_selector, :top_k, :tweedie_variance_power, :objective, :base_score, :eval_metric, :seed, :nthread)`"
":hyperparameter_types" = "`(\"Int64\", \"String\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"String\", \"Float64\", \"Float64\", \"String\", \"Union{Bool, Int64}\", \"String\", \"String\", \"Int64\", \"Int64\", \"String\", \"String\", \"String\", \"Float64\", \"Any\", \"Float64\", \"String\", \"Int64\", \"Float64\", \"Any\", \"Float64\", \"Any\", \"Int64\", \"Int64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LightGBM.LGBMClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s348\"} where var\"_s348\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s348\"} where var\"_s348\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s348\"} where var\"_s348\"<:ScientificTypesBase.Finite, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LightGBM"
":package_license" = "MIT Expat"
":load_path" = "LightGBM.MLJInterface.LGBMClassifier"
":package_uuid" = "7acf609c-83a4-11e9-1ffb-b912bcd3b04a"
":package_url" = "https://github.com/IQVIA-ML/LightGBM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Microsoft LightGBM FFI wrapper: Classifier"
":name" = "LGBMClassifier"
":human_name" = "lgbm classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":predict", ":update"]
":hyperparameters" = "`(:boosting, :num_iterations, :learning_rate, :num_leaves, :max_depth, :tree_learner, :histogram_pool_size, :min_data_in_leaf, :min_sum_hessian_in_leaf, :max_delta_step, :lambda_l1, :lambda_l2, :min_gain_to_split, :feature_fraction, :feature_fraction_bynode, :feature_fraction_seed, :bagging_fraction, :pos_bagging_fraction, :neg_bagging_fraction, :bagging_freq, :bagging_seed, :early_stopping_round, :extra_trees, :extra_seed, :max_bin, :bin_construct_sample_cnt, :init_score, :drop_rate, :max_drop, :skip_drop, :xgboost_dart_mode, :uniform_drop, :drop_seed, :top_rate, :other_rate, :min_data_per_group, :max_cat_threshold, :cat_l2, :cat_smooth, :objective, :categorical_feature, :data_random_seed, :is_sparse, :is_unbalance, :boost_from_average, :scale_pos_weight, :use_missing, :feature_pre_filter, :metric, :metric_freq, :is_training_metric, :ndcg_at, :num_machines, :num_threads, :local_listen_port, :time_out, :machine_list_file, :save_binary, :device_type, :force_col_wise, :force_row_wise, :truncate_booster)`"
":hyperparameter_types" = "`(\"String\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Int64\", \"Int64\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"String\", \"Vector{Int64}\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Any\", \"Bool\", \"Bool\", \"Vector{String}\", \"Int64\", \"Bool\", \"Vector{Int64}\", \"Int64\", \"Int64\", \"Int64\", \"Int64\", \"String\", \"Bool\", \"String\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LightGBM.LGBMRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LightGBM"
":package_license" = "MIT Expat"
":load_path" = "LightGBM.MLJInterface.LGBMRegressor"
":package_uuid" = "7acf609c-83a4-11e9-1ffb-b912bcd3b04a"
":package_url" = "https://github.com/IQVIA-ML/LightGBM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Microsoft LightGBM FFI wrapper: Regressor"
":name" = "LGBMRegressor"
":human_name" = "lgbm regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict", ":update"]
":hyperparameters" = "`(:boosting, :num_iterations, :learning_rate, :num_leaves, :max_depth, :tree_learner, :histogram_pool_size, :min_data_in_leaf, :min_sum_hessian_in_leaf, :max_delta_step, :lambda_l1, :lambda_l2, :min_gain_to_split, :feature_fraction, :feature_fraction_bynode, :feature_fraction_seed, :bagging_fraction, :bagging_freq, :bagging_seed, :early_stopping_round, :extra_trees, :extra_seed, :max_bin, :bin_construct_sample_cnt, :init_score, :drop_rate, :max_drop, :skip_drop, :xgboost_dart_mode, :uniform_drop, :drop_seed, :top_rate, :other_rate, :min_data_per_group, :max_cat_threshold, :cat_l2, :cat_smooth, :objective, :categorical_feature, :data_random_seed, :is_sparse, :is_unbalance, :boost_from_average, :use_missing, :feature_pre_filter, :alpha, :metric, :metric_freq, :is_training_metric, :ndcg_at, :num_machines, :num_threads, :local_listen_port, :time_out, :machine_list_file, :save_binary, :device_type, :force_col_wise, :force_row_wise, :truncate_booster)`"
":hyperparameter_types" = "`(\"String\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int64\", \"Float64\", \"Int64\", \"Int64\", \"Int64\", \"Bool\", \"Int64\", \"Int64\", \"Any\", \"String\", \"Float64\", \"Int64\", \"Float64\", \"Bool\", \"Bool\", \"Int64\", \"Float64\", \"Float64\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"String\", \"Vector{Int64}\", \"Int64\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Bool\", \"Float64\", \"Vector{String}\", \"Int64\", \"Bool\", \"Vector{Int64}\", \"Int64\", \"Int64\", \"Int64\", \"Int64\", \"String\", \"Bool\", \"String\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.AEDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.AEDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nAEDetector(encoder= Chain(),\n           decoder = Chain(),\n           batchsize= 32,\n           epochs = 1,\n           shuffle = false,\n           partial = true,\n           opt = ADAM(),\n           loss = mse)\n```\n\nCalculate the anomaly score of an instance based on the reconstruction loss of an autoencoder, see [1] for an explanation of auto encoders.\n\n## Parameters\n\n```\nencoder::Chain\n```\n\nTransforms the input data into a latent state with a fixed shape.\n\n```\ndecoder::Chain\n```\n\nTransforms the latent state back into the shape of the input data.\n\n```\nbatchsize::Integer\n```\n\nThe number of samples to work through before updating the internal model parameters.\n\n```\nepochs::Integer\n```\n\nThe number of passes of the entire training dataset the machine learning algorithm has completed. \n\n```\nshuffle::Bool\n```\n\nIf `shuffle=true`, shuffles the observations each time iterations are re-started, else no shuffling is performed.\n\n```\npartial::Bool\n```\n\nIf `partial=false`, drops the last mini-batch if it is smaller than the batchsize.\n\n```\nopt::Any\n```\n\nAny Flux-compatibale optimizer, typically a `struct`  that holds all the optimiser parameters along with a definition of `apply!` that defines how to apply the update rule associated with the optimizer.\n\n```\nloss::Function\n```\n\nThe loss function used to calculate the reconstruction error, see [https://fluxml.ai/Flux.jl/stable/models/losses/](https://fluxml.ai/Flux.jl/stable/models/losses/) for examples.\n\n## Examples\n\n```julia\nusing OutlierDetection: AEDetector, fit, score\ndetector = AEDetector()\nX = rand(10, 100)\nresult = fit(detector, X)\ntest_scores = transform(detector, result.model, X)\n```\n\n## References\n\n[1] Aggarwal, Charu C. (2017): Outlier Analysis.\n"
":name" = "AEDetector"
":human_name" = "ae detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :loss)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Integer\", \"Integer\", \"Bool\", \"Bool\", \"Any\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.DSADDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.DSADDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nDSADDetector(encoder = Chain(),\n                decoder = Chain(),\n                batchsize = 32,\n                epochs = 1,\n                shuffle = true,\n                partial = false,\n                opt = ADAM(),\n                loss = mse,\n                eta = 1,\n                eps = 1e-6,\n                callback = _ -> () -> ())\n```\n\nDeep Semi-Supervised Anomaly detection technique based on the distance to a hypersphere center as described in [1].\n\n## Parameters\n\n```\nencoder::Chain\n```\n\nTransforms the input data into a latent state with a fixed shape.\n\n```\ndecoder::Chain\n```\n\nTransforms the latent state back into the shape of the input data.\n\n```\nbatchsize::Integer\n```\n\nThe number of samples to work through before updating the internal model parameters.\n\n```\nepochs::Integer\n```\n\nThe number of passes of the entire training dataset the machine learning algorithm has completed. \n\n```\nshuffle::Bool\n```\n\nIf `shuffle=true`, shuffles the observations each time iterations are re-started, else no shuffling is performed.\n\n```\npartial::Bool\n```\n\nIf `partial=false`, drops the last mini-batch if it is smaller than the batchsize.\n\n```\nopt::Any\n```\n\nAny Flux-compatibale optimizer, typically a `struct`  that holds all the optimiser parameters along with a definition of `apply!` that defines how to apply the update rule associated with the optimizer.\n\n```\nloss::Function\n```\n\nThe loss function used to calculate the reconstruction error, see [https://fluxml.ai/Flux.jl/stable/models/losses/](https://fluxml.ai/Flux.jl/stable/models/losses/) for examples.\n\n```\neta::Real\n```\n\nWeighting parameter for the labeled data; i.e. higher values of eta assign higher weight to labeled data in the svdd loss function. For a sensitivity analysis of this parameter, see [1].\n\n```\neps::Real\n```\n\nBecause the inverse distance used in the svdd loss can lead to division by zero, the parameters `eps` is added for numerical stability.\n\n```\ncallback::Function\n```\n\n*Experimental parameter that might change*. A function to be called after the model parameters have been updated that can call Flux's callback helpers, see [https://fluxml.ai/Flux.jl/stable/utilities/#Callback-Helpers-1](https://fluxml.ai/Flux.jl/stable/utilities/#Callback-Helpers-1).\n\n**Notice:** The parameters `batchsize`, `epochs`, `shuffle`, `partial`, `opt` and `callback` can also be tuples of size 2, specifying the corresponding values for (1) pretraining and (2) training; otherwise the same values are used for pretraining and training.\n\n## Examples\n\n```julia\nusing OutlierDetection: DSADDetector, fit, score\ndetector = DSADDetector()\nX = rand(10, 100)\ny = rand([-1,1], 100)\nmodel = fit(detector, X, y)\ntrain_scores, test_scores = score(detector, model, X)\n```\n\n## References\n\n[1] Ruff, Lukas; Vandermeulen, Robert A.; Görnitz, Nico; Binder, Alexander; Müller, Emmanuel; Müller, Klaus-Robert; Kloft, Marius (2019): Deep Semi-Supervised Anomaly Detection.\n"
":name" = "DSADDetector"
":human_name" = "dsad detector"
":is_supervised" = "`true`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.SupervisedDetector`"
":implemented_methods" = [":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :loss, :eta, :eps, :callback)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Tuple{Integer, Integer}\", \"Tuple{Integer, Integer}\", \"Tuple{Bool, Bool}\", \"Tuple{Bool, Bool}\", \"Any\", \"Function\", \"Number\", \"Number\", \"Tuple{Function, Function}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionNetworks.ESADDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "OutlierDetectionNetworks"
":package_license" = "MIT"
":load_path" = "OutlierDetectionNetworks.ESADDetector"
":package_uuid" = "c7f57e37-4fcb-4a0b-a36c-c2204bc839a7"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionNetworks.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nESADDetector(encoder = Chain(),\n            decoder = Chain(),\n            batchsize = 32,\n            epochs = 1,\n            shuffle = false,\n            partial = true,\n            opt = ADAM(),\n            λ1 = 1,\n            λ2 = 1,\n            noise = identity)\n```\n\nEnd-to-End semi-supervised anomaly detection algorithm similar to DeepSAD, but without the pretraining phase. The algorithm was published by Huang et al., see [1].\n\n## Parameters\n\n```\nencoder::Chain\n```\n\nTransforms the input data into a latent state with a fixed shape.\n\n```\ndecoder::Chain\n```\n\nTransforms the latent state back into the shape of the input data.\n\n```\nbatchsize::Integer\n```\n\nThe number of samples to work through before updating the internal model parameters.\n\n```\nepochs::Integer\n```\n\nThe number of passes of the entire training dataset the machine learning algorithm has completed. \n\n```\nshuffle::Bool\n```\n\nIf `shuffle=true`, shuffles the observations each time iterations are re-started, else no shuffling is performed.\n\n```\npartial::Bool\n```\n\nIf `partial=false`, drops the last mini-batch if it is smaller than the batchsize.\n\n```\nopt::Any\n```\n\nAny Flux-compatibale optimizer, typically a `struct`  that holds all the optimiser parameters along with a definition of `apply!` that defines how to apply the update rule associated with the optimizer.\n\n```\nλ1::Real\n```\n\nWeighting parameter of the norm loss, which minimizes the empirical variance and thus minimizes entropy.\n\n```\nλ2::Real\n```\n\nWeighting parameter of the assistent loss function to define the consistency between the two encoders.\n\n```\nnoise::Function (AbstractArray{T} -> AbstractArray{T})\n```\n\nA function to be applied to a batch of input data to add noise, see [1] for an explanation.\n\n## Examples\n\n```julia\nusing OutlierDetection: ESADDetector, fit, score\ndetector = ESADDetector()\nX = rand(10, 100)\ny = rand([-1,1], 100)\nmodel = fit(detector, X, y)\ntrain_scores, test_scores = score(detector, model, X)\n```\n\n## References\n\n[1] Huang, Chaoqin; Ye, Fei; Zhang, Ya; Wang, Yan-Feng; Tian, Qi (2020): ESAD: End-to-end Deep Semi-supervised Anomaly Detection.\n"
":name" = "ESADDetector"
":human_name" = "esad detector"
":is_supervised" = "`true`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.SupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:encoder, :decoder, :batchsize, :epochs, :shuffle, :partial, :opt, :λ1, :λ2, :noise)`"
":hyperparameter_types" = "`(\"Flux.Chain\", \"Flux.Chain\", \"Integer\", \"Integer\", \"Bool\", \"Bool\", \"Any\", \"Number\", \"Number\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeClassifier]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeClassifier"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Multi-classification with softmax and cross-entropy loss."
":name" = "EvoTreeClassifier"
":human_name" = "evo tree classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeGaussian]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeGaussian"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Gaussian maximum likelihood of μ and σ."
":name" = "EvoTreeGaussian"
":human_name" = "evo tree gaussian"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeRegressor]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeRegressor"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Regression models with various underlying methods: least square, quantile, logistic."
":name" = "EvoTreeRegressor"
":human_name" = "evo tree regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[EvoTrees.EvoTreeCount]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Count`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}, AbstractVector{var\"_s31\"} where var\"_s31\"<:ScientificTypesBase.Count}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Count}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "EvoTrees"
":package_license" = "Apache"
":load_path" = "EvoTrees.EvoTreeCount"
":package_uuid" = "f6006082-12f8-11e9-0c9c-0d5d367ab1e5"
":package_url" = "https://github.com/Evovest/EvoTrees.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Poisson regression fitting λ with max likelihood."
":name" = "EvoTreeCount"
":human_name" = "evo tree count"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:loss, :nrounds, :λ, :γ, :η, :max_depth, :min_weight, :rowsample, :colsample, :nbins, :α, :metric, :rng, :device)`"
":hyperparameter_types" = "`(\"EvoTrees.ModelType\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"AbstractFloat\", \"AbstractFloat\", \"Int64\", \"AbstractFloat\", \"Symbol\", \"Any\", \"Any\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":nrounds"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ConstantClassifier]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}, Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ConstantClassifier"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant classifier (Probabilistic)."
":name" = "ConstantClassifier"
":human_name" = "constant classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fit", ":fitted_params", ":predict"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.Standardizer]
":input_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s258\"} where var\"_s258\"<:ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table, AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s258\"} where var\"_s258\"<:ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`Union{ScientificTypesBase.Table, AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.Standardizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Standardize (whiten) features (columns) of a table."
":name" = "Standardizer"
":human_name" = "standardizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:features, :ignore, :ordered_factor, :count)`"
":hyperparameter_types" = "`(\"Union{Function, AbstractVector{Symbol}}\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.DeterministicConstantClassifier]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.DeterministicConstantClassifier"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant classifier (Deterministic)."
":name" = "DeterministicConstantClassifier"
":human_name" = "deterministic constant classifier"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateTimeTypeToContinuous]
":input_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.ScientificTimeType`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.ScientificTimeType}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.ScientificTimeType`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateTimeTypeToContinuous"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Transform univariate data with element scitype `ScientificDateTime` so that it has `Continuous` element scitype, according to a learned scale. "
":name" = "UnivariateTimeTypeToContinuous"
":human_name" = "univariate time type to continuous"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":transform"]
":hyperparameters" = "`(:zero_time, :step)`"
":hyperparameter_types" = "`(\"Union{Nothing, Dates.TimeType}\", \"Dates.Period\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.OneHotEncoder]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.OneHotEncoder"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "One-hot encode `Finite` (categorical) features (columns) of a table."
":name" = "OneHotEncoder"
":human_name" = "one hot encoder"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":transform"]
":hyperparameters" = "`(:features, :drop_last, :ordered_factor, :ignore)`"
":hyperparameter_types" = "`(\"Vector{Symbol}\", \"Bool\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ContinuousEncoder]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ContinuousEncoder"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Convert all `Finite` (categorical) and `Count` features (columns) of a table to `Continuous` and drop all  remaining non-`Continuous` features. "
":name" = "ContinuousEncoder"
":human_name" = "continuous encoder"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:drop_last, :one_hot_ordered_factors)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateBoxCoxTransformer]
":input_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateBoxCoxTransformer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Box-Cox transform univariate data."
":name" = "UnivariateBoxCoxTransformer"
":human_name" = "univariate box cox transformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:n, :shift)`"
":hyperparameter_types" = "`(\"Int64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.ConstantRegressor]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Continuous}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.ConstantRegressor"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant regressor (Probabilistic)."
":name" = "ConstantRegressor"
":human_name" = "constant regressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":fitted_params", ":predict"]
":hyperparameters" = "`(:distribution_type,)`"
":hyperparameter_types" = "`(\"Type{D} where D<:Distributions.Sampleable\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.FeatureSelector]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.FeatureSelector"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Filter features (columns) of a table by name."
":name" = "FeatureSelector"
":human_name" = "feature selector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:features, :ignore)`"
":hyperparameter_types" = "`(\"Union{Function, Vector{Symbol}}\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateDiscretizer]
":input_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous`"
":output_scitype" = "`AbstractVector{var\"_s258\"} where var\"_s258\"<:ScientificTypesBase.OrderedFactor`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s258\"} where var\"_s258\"<:ScientificTypesBase.OrderedFactor`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Continuous`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateDiscretizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Discretize a continuous variable via quantiles."
":name" = "UnivariateDiscretizer"
":human_name" = "univariate discretizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":inverse_transform", ":transform"]
":hyperparameters" = "`(:n_classes,)`"
":hyperparameter_types" = "`(\"Int64\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.FillImputer]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Table`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`ScientificTypesBase.Table`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.FillImputer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Imputes missing data with a fixed value computed on the non-missing values. A different imputing function can be specified for `Continuous`, `Count` and `Finite` data. "
":name" = "FillImputer"
":human_name" = "fill imputer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:features, :continuous_fill, :count_fill, :finite_fill)`"
":hyperparameter_types" = "`(\"Vector{Symbol}\", \"Function\", \"Function\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.DeterministicConstantRegressor]
":input_scitype" = "`ScientificTypesBase.Table`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table, AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.DeterministicConstantRegressor"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Constant regressor (Deterministic)."
":name" = "DeterministicConstantRegressor"
":human_name" = "deterministic constant regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":fit", ":predict"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateStandardizer]
":input_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Infinite`"
":output_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Infinite}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":inverse_transform_scitype" = "`AbstractVector{var\"_s465\"} where var\"_s465\"<:ScientificTypesBase.Infinite`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateStandardizer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Standardize (whiten) univariate data."
":name" = "UnivariateStandardizer"
":human_name" = "univariate standardizer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":inverse_transform", ":transform"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJModels.UnivariateFillImputer]
":input_scitype" = "`Union{AbstractVector{var\"_s465\"} where var\"_s465\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s257\"} where var\"_s257\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":output_scitype" = "`Union{AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s216\"} where var\"_s216\"<:ScientificTypesBase.Count, AbstractVector{var\"_s4\"} where var\"_s4\"<:ScientificTypesBase.Finite}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{AbstractVector{var\"_s465\"} where var\"_s465\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s257\"} where var\"_s257\"<:Union{Missing, ScientificTypesBase.Finite}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Continuous, AbstractVector{var\"_s216\"} where var\"_s216\"<:ScientificTypesBase.Count, AbstractVector{var\"_s4\"} where var\"_s4\"<:ScientificTypesBase.Finite}`"
":inverse_transform_scitype" = "`Union{AbstractVector{var\"_s465\"} where var\"_s465\"<:Union{Missing, ScientificTypesBase.Continuous}, AbstractVector{var\"_s258\"} where var\"_s258\"<:Union{Missing, ScientificTypesBase.Count}, AbstractVector{var\"_s257\"} where var\"_s257\"<:Union{Missing, ScientificTypesBase.Finite}}`"
":is_pure_julia" = "`true`"
":package_name" = "MLJModels"
":package_license" = "MIT"
":load_path" = "MLJModels.UnivariateFillImputer"
":package_uuid" = "d491faf4-2d78-11e9-2867-c94bc002c0b7"
":package_url" = "https://github.com/alan-turing-institute/MLJModels.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Univariate form of FillImpututer. Imputes missing data with a fixed value computed on the non-missing values. A different imputing function can be specified for `Continuous`, `Count` and `Finite` data. "
":name" = "UnivariateFillImputer"
":human_name" = "univariate fill imputer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:continuous_fill, :count_fill, :finite_fill)`"
":hyperparameter_types" = "`(\"Function\", \"Function\", \"Function\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.MCDDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.MCDDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nMCDDetector(store_precision = true,\n                 assume_centered = false,\n                 support_fraction = nothing,\n                 random_state = nothing)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.mcd](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.mcd)\n"
":name" = "MCDDetector"
":human_name" = "mcd detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:store_precision, :assume_centered, :support_fraction, :random_state)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Union{Nothing, Real}\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.COPODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.COPODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nCOPODDetector()\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.copod](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.copod)\n"
":name" = "COPODDetector"
":human_name" = "copod detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`()`"
":hyperparameter_types" = "`()`"
":hyperparameter_ranges" = "`()`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.HBOSDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.HBOSDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nHBOSDetector(n_bins = 10,\n          alpha = 0.1,\n          tol = 0.5)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.hbos](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.hbos)\n"
":name" = "HBOSDetector"
":human_name" = "hbos detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_bins, :alpha, :tol)`"
":hyperparameter_types" = "`(\"Integer\", \"Real\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.IForestDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.IForestDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nIForestDetector(n_estimators = 100,\n                     max_samples = \"auto\",\n                     max_features = 1.0\n                     bootstrap = false,\n                     behaviour = \"new\",\n                     random_state = nothing,\n                     verbose = 0,\n                     n_jobs = 1)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.iforest](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.iforest)\n"
":name" = "IForestDetector"
":human_name" = "i forest detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_estimators, :max_samples, :max_features, :bootstrap, :behaviour, :random_state, :verbose, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"Union{Real, String}\", \"Real\", \"Bool\", \"String\", \"Union{Nothing, Integer}\", \"Integer\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.SOSDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.SOSDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSOSDetector(perplexity = 4.5,\n         metric = \"minkowski\",\n         eps = 1e-5)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.sos](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.sos)\n"
":name" = "SOSDetector"
":human_name" = "sos detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:perplexity, :metric, :eps)`"
":hyperparameter_types" = "`(\"Real\", \"String\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.ABODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.ABODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nABODDetector(n_neighbors = 5,\n                  method = \"fast\")\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.abod](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.abod)\n"
":name" = "ABODDetector"
":human_name" = "abod detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_neighbors, :method)`"
":hyperparameter_types" = "`(\"Integer\", \"String\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LOFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLOFDetector(n_neighbors = 5,\n                 method = \"largest\",\n                 algorithm = \"auto\",\n                 leaf_size = 30,\n                 metric = \"minkowski\",\n                 p = 2,\n                 metric_params = nothing,\n                 n_jobs = 1)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.lof](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.lof)\n"
":name" = "LOFDetector"
":human_name" = "lof detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_neighbors, :algorithm, :leaf_size, :metric, :p, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Integer\", \"String\", \"Union{Nothing, Integer}\", \"Any\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.PCADetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.PCADetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nPCADetector(n_components = nothing,\n                 n_selected_components = nothing,\n                 copy = true,\n                 whiten = false,\n                 svd_solver = \"auto\",\n                 tol = 0.0\n                 iterated_power = \"auto\",\n                 standardization = true,\n                 weighted = true,\n                 random_state = nothing)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.pca](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.pca)\n"
":name" = "PCADetector"
":human_name" = "pca detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_components, :n_selected_components, :copy, :whiten, :svd_solver, :tol, :iterated_power, :standardization, :weighted, :random_state)`"
":hyperparameter_types" = "`(\"Union{Nothing, Real}\", \"Union{Nothing, Integer}\", \"Bool\", \"Bool\", \"String\", \"Real\", \"Union{Integer, String}\", \"Bool\", \"Bool\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.OCSVMDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.OCSVMDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nOCSVMDetector(kernel = \"rbf\",\n                   degree = 3,\n                   gamma = \"auto\",\n                   coef0 = 0.0,\n                   tol = 0.001,\n                   nu = 0.5,\n                   shrinking = true,\n                   cache_size = 200,\n                   verbose = false,\n                   max_iter = -1)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.ocsvm](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.ocsvm)\n"
":name" = "OCSVMDetector"
":human_name" = "ocsvm detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:kernel, :degree, :gamma, :coef0, :tol, :nu, :shrinking, :cache_size, :verbose, :max_iter)`"
":hyperparameter_types" = "`(\"String\", \"Integer\", \"Union{Real, String}\", \"Real\", \"Real\", \"Real\", \"Bool\", \"Integer\", \"Bool\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.SODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.SODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSODDetector(n_neighbors = 5,\n                 ref_set = 10,\n                 alpha = 0.8)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.sod](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.sod)\n"
":name" = "SODDetector"
":human_name" = "sod detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_neighbors, :ref_set, :alpha)`"
":hyperparameter_types" = "`(\"Integer\", \"Integer\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LODADetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LODADetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLODADetector(n_bins = 10,\n                  n_random_cuts = 100)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.loda](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.loda)\n"
":name" = "LODADetector"
":human_name" = "loda detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_bins, :n_random_cuts)`"
":hyperparameter_types" = "`(\"Integer\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.KNNDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.KNNDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nKNNDetector(n_neighbors = 5,\n         method = \"largest\",\n         radius = 1.0,\n         algorithm = \"auto\",\n         leaf_size = 30,\n         metric = \"minkowski\",\n         p = 2,\n         metric_params = nothing,\n         n_jobs = 1)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.knn](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.knn)\n"
":name" = "KNNDetector"
":human_name" = "knn detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_neighbors, :method, :radius, :algorithm, :leaf_size, :metric, :p, :metric_params, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Real\", \"String\", \"Integer\", \"String\", \"Union{Nothing, Integer}\", \"Any\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.COFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.COFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nCOFDetector(n_neighbors = 5)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.cof](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.cof)\n"
":name" = "COFDetector"
":human_name" = "cof detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_neighbors,)`"
":hyperparameter_types" = "`(\"Integer\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.CBLOFDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.CBLOFDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nCBLOFDetector(n_clusters = 8,\n                   alpha = 0.9,\n                   beta = 5,\n                   use_weights = false,\n                   random_state = nothing,\n                   n_jobs = 1)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.cblof](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.cblof)\n"
":name" = "CBLOFDetector"
":human_name" = "cblof detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_clusters, :alpha, :beta, :use_weights, :random_state, :n_jobs)`"
":hyperparameter_types" = "`(\"Integer\", \"Real\", \"Real\", \"Bool\", \"Union{Nothing, Integer}\", \"Integer\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LOCIDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LOCIDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLOCIDetector(alpha = 0.5,\n                  k = 3)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.loci](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.loci)\n"
":name" = "LOCIDetector"
":human_name" = "loci detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:alpha, :k)`"
":hyperparameter_types" = "`(\"Real\", \"Real\")`"
":hyperparameter_ranges" = "`(nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.LMDDDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.LMDDDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLMDDDetector(n_iter = 50,\n                  dis_measure = \"aad\",\n                  random_state = nothing)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.lmdd](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.lmdd)\n"
":name" = "LMDDDetector"
":human_name" = "lmdd detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:n_iter, :dis_measure, :random_state)`"
":hyperparameter_types" = "`(\"Integer\", \"String\", \"Union{Nothing, Integer}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[OutlierDetectionPython.RODDetector]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}`"
":output_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":target_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}`"
":fit_data_scitype" = "`Union{Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}}, Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous}, AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.OrderedFactor{2}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s3\"} where var\"_s3\"<:ScientificTypesBase.Continuous`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "OutlierDetectionPython"
":package_license" = "MIT"
":load_path" = "OutlierDetectionPython.RODDetector"
":package_uuid" = "2449c660-d36c-460e-a68b-92ab3c865b3e"
":package_url" = "https://github.com/OutlierDetectionJL/OutlierDetectionPython.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nRODDetector(parallel_execution = false)\n```\n\n[https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.rod](https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.rod)\n"
":name" = "RODDetector"
":human_name" = "rod detector"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.UnsupervisedDetector`"
":implemented_methods" = [":clean!", ":reformat", ":selectrows", ":fit", ":transform"]
":hyperparameters" = "`(:parallel_execution,)`"
":hyperparameter_types" = "`(\"Bool\",)`"
":hyperparameter_ranges" = "`(nothing,)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.EpsilonSVR]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.EpsilonSVR"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nEpsilonSVR(; kwargs...)\n```\n\nKernel support vector machine regressor using LIBSVM: https://www.csie.ntu.edu.tw/~cjlin/libsvm/\n\nIf `gamma==-1.0` then  `gamma = 1/nfeatures is used in fitting. If`gamma==0.0`then a`gamma = 1/(var(X) * nfeatures)` is used in fitting\n\nSee also NuSVR\n"
":name" = "EpsilonSVR"
":human_name" = "epsilon svr"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:kernel, :gamma, :epsilon, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.LinearSVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.LinearSVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nLinearSVC(; kwargs...)\n```\n\nLinear support vector machine classifier using LIBLINEAR: https://www.csie.ntu.edu.tw/~cjlin/liblinear/\n\nSee also SVC, NuSVC\n"
":name" = "LinearSVC"
":human_name" = "linear svc"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:solver, :weights, :tolerance, :cost, :p, :bias)`"
":hyperparameter_types" = "`(\"LIBSVM.Linearsolver.LINEARSOLVER\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Float64\", \"Float64\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.NuSVR]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.NuSVR"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nNuSVR(; kwargs...)\n```\n\nKernel support vector machine regressor using LIBSVM: https://www.csie.ntu.edu.tw/~cjlin/libsvm/\n\nIf `gamma==-1.0` then  `gamma = 1/nfeatures is used in fitting. If`gamma==0.0`then a`gamma = 1/(var(X) * nfeatures)` is used in fitting\n\nSee also EpsilonSVR\n"
":name" = "NuSVR"
":human_name" = "nu svr"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:kernel, :gamma, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.NuSVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.NuSVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nNuSVC(; kwargs...)\n```\n\nKernel support vector machine classifier using LIBSVM: https://www.csie.ntu.edu.tw/~cjlin/libsvm/\n\nIf `gamma==-1.0` then  `gamma = 1/nfeatures is used in fitting. If`gamma==0.0`then a`gamma = 1/(var(X) * nfeatures)` is used in fitting\n\nSee also LinearSVC, SVC\n"
":name" = "NuSVC"
":human_name" = "nu svc"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:kernel, :gamma, :weights, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.SVC]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s221\"} where var\"_s221\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Finite`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.SVC"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nSVC(; kwargs...)\n```\n\nKernel support vector machine classifier using LIBSVM: https://www.csie.ntu.edu.tw/~cjlin/libsvm/ If `gamma==-1.0` then  `gamma = 1/nfeatures is used in fitting. If`gamma==0.0`then a`gamma = 1/(var(X) * nfeatures)` is used in fitting\n\nSee also LinearSVC, NuSVC\n"
":name" = "SVC"
":human_name" = "svc"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":clean!", ":fit", ":predict"]
":hyperparameters" = "`(:kernel, :gamma, :weights, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking, :probability)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Union{Nothing, Dict}\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[LIBSVM.OneClassSVM]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Binary`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`AbstractVector{var\"_s64\"} where var\"_s64\"<:ScientificTypesBase.Binary`"
":inverse_transform_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":is_pure_julia" = "`false`"
":package_name" = "LIBSVM"
":package_license" = "unknown"
":load_path" = "MLJLIBSVMInterface.OneClassSVM"
":package_uuid" = "b1bec4e5-fd48-53fe-b0cb-9723c09d164b"
":package_url" = "https://github.com/mpastell/LIBSVM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "```\nOneClassSVM\n```\n\nModel type for one class svm, based on\n[LIBSVM.jl](https://github.com/mpastell/LIBSVM.jl), and implementing the MLJ\nmodel interface.\n\nFrom MLJ, the type can be imported using\n\n```\nOneClassSVM = @load OneClassSVM pkg=LIBSVM\n```\n\nDo `model = OneClassSVM()` to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in\n`OneClassSVM(kernel=...)`.\n# Hyper-parameters\n\n- `kernel = RadialBasis`\n\n- `gamma = 0.0`\n\n- `nu = 0.1`\n\n- `cost = 1.0`\n\n- `cachesize = 200.0`\n\n- `degree = 3`\n\n- `coef0 = 0.0`\n\n- `tolerance = 0.001`\n\n- `shrinking = true`\n\n"
":name" = "OneClassSVM"
":human_name" = "one class svm"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":transform"]
":hyperparameters" = "`(:kernel, :gamma, :nu, :cost, :cachesize, :degree, :coef0, :tolerance, :shrinking)`"
":hyperparameter_types" = "`(\"LIBSVM.Kernel.KERNEL\", \"Float64\", \"Float64\", \"Float64\", \"Float64\", \"Int32\", \"Float64\", \"Float64\", \"Bool\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[TSVD.TSVDTransformer]
":input_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":output_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":target_scitype" = "`ScientificTypesBase.Unknown`"
":fit_data_scitype" = "`Tuple{Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}}`"
":predict_scitype" = "`ScientificTypesBase.Unknown`"
":transform_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":inverse_transform_scitype" = "`Union{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractMatrix{ScientificTypesBase.Continuous}}`"
":is_pure_julia" = "`true`"
":package_name" = "TSVD"
":package_license" = "MIT"
":load_path" = "MLJTSVDInterface.TSVDTransformer"
":package_uuid" = "9449cd9e-2762-5aa3-a617-5413e99d722e"
":package_url" = "https://github.com/JuliaLinearAlgebra/TSVD.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Truncated SVD dimensionality reduction"
":name" = "TSVDTransformer"
":human_name" = "tsvd transformer"
":is_supervised" = "`false`"
":prediction_type" = ":unknown"
":abstract_type" = "`MLJModelInterface.Unsupervised`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":transform"]
":hyperparameters" = "`(:nvals, :maxiter, :rng)`"
":hyperparameter_types" = "`(\"Int64\", \"Int64\", \"Union{Int64, Random.AbstractRNG}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearBinaryClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s91\"} where var\"_s91\"<:ScientificTypesBase.Binary`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s91\"} where var\"_s91\"<:ScientificTypesBase.Binary}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s91\"} where var\"_s91\"<:ScientificTypesBase.Binary, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Binary}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearBinaryClassifier"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear binary classifier with specified link (e.g. logistic)."
":name" = "LinearBinaryClassifier"
":human_name" = "linear binary classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":predict_mean"]
":hyperparameters" = "`(:fit_intercept, :link, :offsetcol, :maxiter, :atol, :rtol, :minstepfac, :report_keys)`"
":hyperparameter_types" = "`(\"Bool\", \"GLM.Link01\", \"Union{Nothing, Symbol}\", \"Integer\", \"Real\", \"Real\", \"Real\", \"Union{Nothing, AbstractVector{Symbol}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearCountRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Count}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Count}}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Count}, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Count}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearCountRegressor"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear count regressor with specified link and distribution (e.g. log link and poisson)."
":name" = "LinearCountRegressor"
":human_name" = "linear count regressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":predict_mean"]
":hyperparameters" = "`(:fit_intercept, :distribution, :link, :offsetcol, :maxiter, :atol, :rtol, :minstepfac, :report_keys)`"
":hyperparameter_types" = "`(\"Bool\", \"Distributions.Distribution\", \"GLM.Link\", \"Union{Nothing, Symbol}\", \"Integer\", \"Real\", \"Real\", \"Real\", \"Union{Nothing, AbstractVector{Symbol}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[GLM.LinearRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{ScientificTypesBase.Continuous}`"
":fit_data_scitype" = "`Union{Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}}, Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{ScientificTypesBase.Continuous}, AbstractVector{var\"_s37\"} where var\"_s37\"<:Union{ScientificTypesBase.Continuous, ScientificTypesBase.Count}}}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{ScientificTypesBase.Continuous}}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "GLM"
":package_license" = "MIT"
":load_path" = "MLJGLMInterface.LinearRegressor"
":package_uuid" = "38e38edf-8417-5370-95a0-9cbb8c7f171a"
":package_url" = "https://github.com/JuliaStats/GLM.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`true`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "Linear regressor (OLS) with a Normal model."
":name" = "LinearRegressor"
":human_name" = "linear regressor"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":clean!", ":fit", ":fitted_params", ":predict", ":predict_mean"]
":hyperparameters" = "`(:fit_intercept, :dropcollinear, :offsetcol, :report_keys)`"
":hyperparameter_types" = "`(\"Bool\", \"Bool\", \"Union{Nothing, Symbol}\", \"Union{Nothing, AbstractVector{Symbol}}\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing)`"
":iteration_parameter" = "`nothing`"
":supports_training_losses" = "`false`"
":deep_properties" = "`()`"

[MLJFlux.MultitargetNeuralNetworkRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)}`"
":predict_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.MultitargetNeuralNetworkRegressor"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making deterministic predictions of a `Continuous` multi-target, presented as a table, given a table of `Continuous` features. "
":name" = "MultitargetNeuralNetworkRegressor"
":human_name" = "multitarget neural network regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.NeuralNetworkClassifier]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Finite`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Finite}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Finite}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.NeuralNetworkClassifier"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making probabilistic predictions of a `Multiclass` or `OrderedFactor` target, given a table of `Continuous` features. "
":name" = "NeuralNetworkClassifier"
":human_name" = "neural network classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :finaliser, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Int64, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.ImageClassifier]
":input_scitype" = "`AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Image`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s75\"} where var\"_s75\"<:ScientificTypesBase.Multiclass`"
":fit_data_scitype" = "`Tuple{AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Image, AbstractVector{var\"_s75\"} where var\"_s75\"<:ScientificTypesBase.Multiclass}`"
":predict_scitype" = "`AbstractVector{ScientificTypesBase.Density{_s25} where _s25<:ScientificTypesBase.Multiclass}`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.ImageClassifier"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making probabilistic predictions of a `GrayImage` target, given a table of `Continuous` features. "
":name" = "ImageClassifier"
":human_name" = "image classifier"
":is_supervised" = "`true`"
":prediction_type" = ":probabilistic"
":abstract_type" = "`MLJModelInterface.Probabilistic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :finaliser, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Int64, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"

[MLJFlux.NeuralNetworkRegressor]
":input_scitype" = "`ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous)`"
":output_scitype" = "`ScientificTypesBase.Unknown`"
":target_scitype" = "`AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Continuous`"
":fit_data_scitype" = "`Tuple{ScientificTypesBase.Table{var\"_s28\"} where var\"_s28\"<:(AbstractVector{var\"_s29\"} where var\"_s29\"<:ScientificTypesBase.Continuous), AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Continuous}`"
":predict_scitype" = "`AbstractVector{var\"_s76\"} where var\"_s76\"<:ScientificTypesBase.Continuous`"
":transform_scitype" = "`ScientificTypesBase.Unknown`"
":inverse_transform_scitype" = "`ScientificTypesBase.Unknown`"
":is_pure_julia" = "`true`"
":package_name" = "MLJFlux"
":package_license" = "MIT"
":load_path" = "MLJFlux.NeuralNetworkRegressor"
":package_uuid" = "094fc8d1-fd35-5302-93ea-dabda2abf845"
":package_url" = "https://github.com/alan-turing-institute/MLJFlux.jl"
":is_wrapper" = "`false`"
":supports_weights" = "`false`"
":supports_class_weights" = "`false`"
":supports_online" = "`false`"
":docstring" = "A neural network model for making deterministic predictions of a `Continuous` target, given a table of `Continuous` features. "
":name" = "NeuralNetworkRegressor"
":human_name" = "neural network regressor"
":is_supervised" = "`true`"
":prediction_type" = ":deterministic"
":abstract_type" = "`MLJModelInterface.Deterministic`"
":implemented_methods" = [":predict"]
":hyperparameters" = "`(:builder, :optimiser, :loss, :epochs, :batch_size, :lambda, :alpha, :rng, :optimiser_changes_trigger_retraining, :acceleration)`"
":hyperparameter_types" = "`(\"Any\", \"Any\", \"Any\", \"Int64\", \"Int64\", \"Float64\", \"Float64\", \"Union{Integer, Random.AbstractRNG}\", \"Bool\", \"ComputationalResources.AbstractResource\")`"
":hyperparameter_ranges" = "`(nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing, nothing)`"
":iteration_parameter" = ":epochs"
":supports_training_losses" = "`true`"
":deep_properties" = "`(:optimiser, :builder)`"
